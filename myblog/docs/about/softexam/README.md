

# 软件设计师

## P1 软件设计师考试介绍

**考试形式**：

- 计算机与软件工程知识，150分钟，笔试，选择题。
- 软件设计，150分钟，笔试，问答题。



**历年考试知识点**：

![历年考试知识点](/img/softexam.png)



**历年考试软件设计题型**：

![历年考试软件设计题型](/img/software_design.png)



## P2 计算机组成与体系结构

课程内容提要 (6分)：

- 数据的表示。 
  - 涉及到数据进制的转换，计算机中使用二进制数据，但是在日常生活习惯使用十进制。
  - 为了计算的方便，提出了八进制，十六进制等，这些进制在计算某些问题的时候有可能用到。比如如在存储体系这一块有计算用多少块芯片组成多大的存储空间；网络部分计算IP地址，子网掩码等。
- 计算机结构。
  - 涉及的内容比较多，但真正考察的比较多的是CPU中寄存器划分的问题。
  - 哪些寄存器是放在运算器中，哪些寄存器是属于控制器，这些要区分得清楚。
  - 对于常见的寄存器，我们还要了解它的基本特性是什么？它是做什么用的。
- Flynn分类法。
  - 计算机的分类方法，把计算机分成4大类别，实际应用过程中并没有区分哪么严格，有些类别只是在理论层面的东西。
- CISC和RISC。
  - 计算机的指令集，这两种指令集的特点需要区分开。
- 流水线技术。
  - 主要是考察一些计算方面的问题。
- 存储系统。
  - 即有概念也有计算方面的问题需要了解和掌握。
- 总线系统。
  - 了解最基础的总线的分类和概念。
- 可靠性。
  - 串联，并联，串并混合的情况。
- 校验码。
  - 校验码的作用。
  - 常见的校验码有哪些。
  - CRC校验码，海明校验码各自的特点，编码解码过程。

## P3 数据的表示(进制的转换)

- 数据的表示

  - 任何进制转换成十进制，都是使用**按权展开法**进行处理。
  - R进制转十进制使用按权展开法，其具体操作方式为：将R进制数的每一位数值用R<sup>k</sup>形式表示，即幂的底数为R,指数为k,k与该位和小数点之间的距离有关，当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1。
  - 例如二进制 10100.01=1 \* *2<sup>4</sup> + 1 \* 2*<sup>2</sup> + 1 \* 2<sup>-2</sup>
  - 例如七进制 604.01=6 \* *7<sup>2</sup> + 4 \* 7*<sup>0</sup> + 1 \* 7<sup>-2</sup>
  - 十进制转R进制使用**短除法**，例如将94转换成二进制数为：

  ```
  2|94 余 0
  2|47 余 1
  2|23 余 1
  2|11 余 1
  2|5  余 1
  2|2  余 0
  2|1  余 1
    0
  从下往上面开始读取余数值，所以最后的结果是 1011110
  ```

- 二进制转八进制与十六进制。

  - 在计算机上面要用到的是二进制，但我们在计算过程中使用二进制就比较繁杂，二进制数比较长，十进制只有4位数时，二进制多达十多位，不太好计算，操作起来不太好操作。
  - 二进制与八进制、十六进制之间有严整的对应关系。
  - 每三个二进制位可以对应一个八进制位，从右到左每三个二进制位三位三位的分段，然后再把每一个段转成八进制。
  - 每四个二进制位对应一个埂十六进制位，从右到左每四个二进制位四位四位的分段，然后再把每一个段转成十六进制位。

  如将上面的94对应的二进制1011110转成八进制和十六进制：

  ```
  十进制 94
  二进制 1011110
  
  转成八进制
  分段 1 011 110
  转换 1   3   6
  即：94 = 1*8*8 + 3*8 + 6
  八进制为 136
  
  转成十六进制
  分段 101 1110
  转换   5    e
  即： 94 = 5*16 + e = 80 + 14
  十六进制中，0，1，2，3，4，5，6，7，8，9，10(a)，11(b)，12(c)，13(d)，14(e)，15(f) 
  ```

你可以在 [https://tool.lu/hexconvert/](https://tool.lu/hexconvert/) 页面验证你的进制转换。

## P4 数据的表示(原码反码补码移码)

- 各种数值在计算机中表示的形式称为机器数。
- 移码主要是为了在数轴上面将负数显示在下方正数显示在上方。
- 原码、反码、补码和移码
  - 正数： 原码 = 反码 = 补码，移码 = 补码符号位取反
  - 负数：反码 = 原码符号位不变，其他位取反；补码 = 反码 + 1；移码 = 补码符号位取反

|      | 数值1     | 数值-1    | 1-1       |
| ---- | --------- | --------- | --------- |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 |
| 移码 | 1000 0001 | 0111 1111 | 1000 000  |

- 取值范围
  - n为机器字长，如n=8
  - 原码 ： -(2<sup>n-1</sup> - 1) ~  (2<sup>n-1</sup> - 1) ，如n=8，则范围为-127~127
  - 反码 ： -(2<sup>n-1</sup> - 1) ~  (2<sup>n-1</sup> - 1) ，如n=8，则范围为-127~127
  - 补码 ： -2<sup>n-1</sup>  ~  (2<sup>n-1</sup> - 1) ，如n=8，则范围为-128~127
  - 移码 ： -2<sup>n-1</sup>  ~  (2<sup>n-1</sup> - 1) ，如n=8，则范围为-128~127

  

## P5 数据的表示(浮点数运算)

- 浮点数表示 N = M * R<sup>e</sup>
- 其中，M称为尾数，e是指数，R为基数。
- 操作时，先要对阶，再进行尾数计算，最后再进行结果格式化。

## P6 CPU结构(运算器和控制器的组成)

- CPU是中央处理单元，是计算机的核心部件，它负责获取程序指令、对指令进行译码并加以执行。
- 主机是计算机的核心部分，整个计算机的组成就是主机+外设。主机并不是平常所说的主机箱里面的部件呢，不是这么回事。
- 计算机结构里面所说的主机比主机箱里面的部件要少。
- 主机只包括两个部分：CPU和主存储器（也就是内存）。
- 像硬盘、显卡、声卡等归为外设。只有CPU和内存属于主机的！
- CPU中包含运算器和控制器。
- 运算器和控制器的构成是经常考到的一个知识点。
- 运算器主要功能有：执行所有的算术运算；执行所有的逻辑运算并进行逻辑测试。
- 运算器主要部件有算术逻辑单元ALU（实现对数据的算术和逻辑运算），累加寄存器AC(通用寄存器，不仅仅只做加法运算，减法运行也会用到这个寄存器)，数据缓冲寄存器DR(对内存储器进行读写操作时，用来暂存数据), 状态条件寄存器PSW（这个寄存器非常有特色，经常被考到，用来存在运算标志、标志位、状态等信息的，主要分为状态标志和控制标志）。
- 控制器主要部件有指令寄存器IR，程序计数器PC(程序运行当前指令时需要了解下一条指令在什么位置，这个就是由程序计数器来完成)，指令译码器ID，时序部件。

## P7 Flynn分类法简介

- Flynn分类是一种计算机体系结构分类方法。
- Flynn分类依据是两个指标：指令流、数据流。
- 指令流、数据流都可以分为两种类型，单和多。如单指令流、单数据流、多指令流、多数据流。实际上是按穷举的方式进行分类。
- 分类就会分成4种：单指令流单数据流，单指令流多数据流，多指令流单数据流，多指令流多数据流。
- 单指令流单数据流（Single Instruction stream Single Data stream, SISD）。
- 单指令流多数据流（Single Instruction stream Multiple Data stream, SIMD）。
- 多指令流单数据流（Multiple Instruction stream Single Data stream, MISD）。
- 多指令流多数据流（Multiple Instruction stream Multiple Data stream, MIMD）。

| 体系结构类型           | 结构                                         | 关键特性                                                     | 代表                                                         |
| ---------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单指令流单数据流  SISD | 控制部分：一个；处理器：一个；主存模块：一个 |                                                              | 单处理器系统，在PC/服务器领域已经看不到了，在单片机系统上面仍然存在，并且比较多见 |
| 单指令流多数据流 SIMD  | 控制部分：一个；处理器：多个；主存模块：多个 | 各处理器以异步的形式执行同一条指令（每个运算部件的输入可能不一样） | 并行处理机，主要应用在**阵列处理机**，超级向量处理机。阵列处理机适合去处理数组相关的计算 |
| 多指令流单数据流MISD   | 控制部分：多个；处理器：一个；主存模块：多个 | **被证明是不可能，至少是不实际**，是理论上面的模型           | 目前没有，有文献称流水线计算机为此类                         |
| 多指令流多数据流MIMD   | 控制部分：多个；处理器：多个；主存模块：多个 | 能够实现作业、任务、指令等各级全面并行                       | 目前来说最见的。多处理机系统，多计算机                       |

## P8 CISC和RISC

- CISC - Complex Instruction Set Computer 复杂指令集计算机。
- RISC - Reduced Instruction Set Computer 精简指令集计算机。

| 指令系统类型          | 指令                                                         | 寻址方式   | 实现方式                                             | 其他                           |
| --------------------- | ------------------------------------------------------------ | ---------- | ---------------------------------------------------- | ------------------------------ |
| 复杂指令集计算机 CISC | 数量多，使用频率差别大，可变长格式                           | 支持多种   | 微程序控制技术(微码)                                 | 研制周期长，成本高，出错几率大 |
| 精简指令集计算机 RISC | 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式少 | 增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线 | 优化编译，有效支持高级语言     |

- 如何理解CISC和RISC：
  - CISC是以前比较常用的指令集，是在计算机没有大规模使用前提出来的，在这个时候计算机是奢侈品，比如一个机构需要一台计算机，这个时候需要找到厂商为我们定制一台计算机，这台计算机从硬件到指令系统都是定制的，比如这台计算机需要用来处理天气预报信息，需要根据运算能力来设计这台计算机，这台计算机不是我们看到的笔记本或台式机那么大，而是一间房子那么大，很多元器件组起来的，然后你要进行什么样的业务处理，就给你设计哪些指令，然后再在指令基础上来编程去完成业务，这还是很多年前的事情。有这样的历史背景和环境之后，我们就可以知道CISC为什么是复杂指令集，是因为这种指令系统根据不同的用户，会做不同的指令，而且指令非常多，数量多。
  - 在计算机的发展过程中，原来基本都是各个单位的专用设备，后来计算机成为通用设备，每个计算机买回去，安装上软件就希望能够直接跑。因此需要考虑精简计算机的指令系统，希望它适应能力更强一些，而且需要做优化。我们开始把繁杂的指令系统开始简化，简化到最基本的操作，然后复杂的操作都用基本的操作来替代，比如乘法指令比较复杂，我们将乘法指令移除掉，而是将乘法看成多个加法指令的累加这样的形式来完成，这样一来大大的降低了整个系统的指令数量，所以叫精简指令集。
  - 所以再来看表中的内容，指令数量毫无疑问是复杂指令集CISC的多一些，复杂指令集中有很多的指令，有些指令可能需要频繁使用到，如简单指令，而复杂指令使用频率不见得高，这就是需要将复杂指令排除掉的原因，因此使用频率差别大；一般使用可变长度的指令，这是指令在系统上面会有二进制编码，编码长度可以不同，而在精简指令集中，指令数量少，使用频率也差不多，就用定长格式，所有的指令长度是一样的，精简指令集为了提高效率，引入了寄存器，绝大部分操作都是针对寄存器进行的，寄存器速度极快，效率极高，寄存器只用Load(读取)/Store(存入)操作内存，其他的都读取寄存器，所以得到了比较高的效率。
  - RISC大大超越CISC，RiSC是主流。

## P9 流水线的基本概念

- 流水线概念

  - 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。
  - 指令的执行步骤： 取指  --> 分析 -->  执行 -->
  - 指令的控制方式有顺序方式、重叠方式和流水方式3种。
  - 顺序方式是指各条机器指令之间顺序串行地执行，执行完一条指令后才取下一条指令，而且每条机器指令内部的各个微操作也是顺序串行地执行。这种方式的优点是控制简单，缺点是速度慢，机器各部件利用率低。
  - 重叠方式是指解释第K条指令的操作完成之前就可以开始解释第K+1条指令。通常采用的是一次重叠，即在任何时候，指令分析部件和指令执行部件都只有相邻两条指令在重叠解释。这种方式的优点是速度有所提高，控制也不复杂，缺点是会出现冲突、转移和相关等问题。
  - 流水方式是模仿工业生产过程的流水线（如汽车装配线）而提出的一种指令控制方式。

![流水线](/img/pipeline.png)

左边图是没有使用流水线执行指令情况，右边是使用流水线执行指令情况。

左边顺序执行在取指后、分析指令、再执行指令。这三个步骤是由不同部件来完成的，可以看出有大量部件是处于空隙状态的（如图中的空白位置），可以看到顺序执行时间只使用了少量的时间片，而大量的时间片被空隙浪费了。

而右边的流水线执行指令情况下，取出第1条指令后，该部件马上去对第2条指令进行取指，这样这个部件的时间就没有浪费；而分析指令部件在分析完第1条指令后马上就分析第2条指令，时间片也没有浪费；执行部件在执行完第1条指令后马上执行第2条指令，时间片也没有浪费。即不需要第1条执行执行完成才进行第2条指令的取指工作。

这就好比在工业领域第一次应用流水线技术，福特工司在没有利用流水线技术时，组装环节，分班组进行组装，一个班组把一辆汽车🚙组装完成后，再立即进行另一辆车的组装，看似没有时间空隙，但实际上在组装一台车的过程中有大量的工人在处于休息状态（空隙），如有些人只装配发动机、有些人只装配轮胎，我们知道不可能所有人同一时间一拥而上一起来组装车辆，而是在车架上面先装发动机，再装变速箱，再装外壳，再装玻璃之类的，这个过程一开始装发动机的人在忙活，装玻璃的人在休息，装变速箱的人忙活的时候装玻璃的人仍然在休息，。。。，安装玻璃的人忙活的时候其他的工人却在休息，这样可以看到大量的工人处于休息状态，造成大量人工的浪费。

福特指出利用流水线技术，由流水线的传送带把车传送过来，每个工人只负责他们需要做的一小部分工作，比如说工人需要把轮胎放在轴上，车辆到达工人面前，他只需要把轮胎放在轴上，不需要管别的，传送带将车辆传到下一个环节，下一个环节的工人再进行轮胎螺丝的安装，因此针对安装轮胎的这个工人，他只需要在有车辆过来，并将轮胎放在轴上即可，然后接着给下一辆车将轮胎放在轴上，这样看工人的时间被充分利用了，浪费的人工时间比较少，工作效率大大提高了！

流水线不仅仅只应用于计算机相应领域，也用在工业领域!

## P10 流水线周期及流水线执行时间计算

- 流水线周期是指(取指、分析和执行操作中)执行时间最长的一段。如取指2ns，分析2ns，执行1ns，则周期是2ns。即指令执行过程中的几个步骤(如取指阶段、分析阶段、执行阶段)中最耗时的阶段。
- 流水线计算公式为：
  - 1条指令执行时间 + (指令条数-1)* 流水线周期
  - 理论公式：(t1 + t2 + t3 + ... + tk) + (n -1) *  &Delta;t
  - 实践公式： (k + n -1) * &Delta;t  ， 其中k是分几段

因为不工整的时间片导致后面计算带来不便，可以将每个阶段看成执行时长都是一个周期，这样所有阶段的执行时间都是一个周期，这时看实践公式计算就方便一些。

流水线执行过程：

![](/img/Snipaste_2020-09-04_07-12-28.png)

例题：

![](/img/Snipaste_2020-09-04_07-14-02.png)

由于取指2ns，分析2ns，执行1ns，那么周期按最长的一段计算，最长的一段是取指或分析，都是2ns，因此周期&Delta;t是2ns。

那么100条指令执行时间：

理论公式：(2 + 2 + 1) + (100 -1) * 2 = 5 + 200 -2 = 203 ns

实践公式： (3 + 100 -1) * 2 = 204ns

考试中两种方式的可能性都有，首先使用理论公式，如果理论公式没有正确答案则使用实践公式。

## P11 流水线吞吐率计算

- 流水线吞吐率概念

![](/img/Snipaste_2020-09-04_20-36-01.png)

- 流水线的吞吐率(Though Put rate, TP)是指在单位时间内流水线所完成的任务数量或输出的结果数量。

- TP = 指令条数 / 流水线执行时间

- 流水线最大吞吐率：

![](/img/tpmax.gif)



我们经常听到某港口的年吞吐率指一年内进出港口的货物情况数量。

我们来计算P10中示例的吞吐率为例。

TP = 指令条数100 / 流水线执行时间 203ns 

TPmax = 1 / &Delta;t = 1 / 2ns 



## P12 流水线的加速比

- 流水线的加速比是指完成同样的一批任务，不使用流水线所用的时间与使用流水线所使用的时间之比。
- 流水线加速比 S = 不使用流水线执行时间 /  使用流水线执行时间 。

我们看一下，P10中的示例，来计算一下加速比。

不使用流水线需要的时间 =  （取指2ns + 分析2ns + 执行1ns） * 100条指令  = 500 ns

使用流水线需要的时间 = (2 + 2 + 1) + (100 -1) * 2 = 5 + 200 -2 = 203 ns

因此流水线的加速比 = 500ns / 203ns = 2.46

```sh
$ echo 'scale=2;500/203'|bc
2.46
```

加速比越高说明使用流水线的效果越明显！



- 流水线的效率： 流水线的效率是指流水线的设备利用率。在时间图中，流水的线的效率定义为n个任务占用的时空区与k个流水段总的时间区之比。

![](/img/Snipaste_2020-09-04_21-10-38.png)

如上面这个图中，S1、S2、S3前三个阶段都是&Delta;t ，S4阶段是3&Delta;t。

此时流水线执行完4个任务所用的时间 = （1 + 1 + 1 + 3）* &Delta;t * 4  = 20 &Delta;t

而此时总的时间片时间 = 15 &Delta;t * 4 = 60 &Delta;t

此时可以看到流水线的效率 = 24&Delta;t / 60&Delta;t = 40%



流水线效率其实是衡量在整个在时间片的空间上面，有多少空间被我们的流水线所利用。提出这个值的含义、价值在于提醒我们，如何去设置流水线来让流水线效率更高。

上面的示例可以看到，有一个阶段S4耗时比较长，其他阶段时间都差不多，这个流水线的效率比较低。

流水线如果各个阶段之间的时间都差不多，就像前面P10中各个阶段的时间差不多，效率相对来说比较高。

## P13 计算机层次化存储结构

- 在存储这一块我们主要要了解以下几方面内容：
  - 存储的整体结构
  - cache相关知识
  - 内存相关知识
- 层次化存储结构， 我们需要了解到：
  - 基本的存储结构是如何划分的？
  - 哪些存储器性能比较好，哪些存储器容量比较大？
  - 为什么要以这种层次化来组织存储结构？

![](/img/Snipaste_2020-09-04_21-41-16.png)

- 在整个存储结构中，性能最高速度最快的是寄存器，存在于CPU内。

- Cache是高速缓存存储器

  - Cache不是必须的，拿走Cache的话，也可以，内存也可以与CPU交互，但是这时候速度会很慢，速度可能慢上100百，Cache单位级别是KB、MB等。
  - Cache相对于内存来说，容量极小，但是加了Cache后，速度提升了十倍百倍，速度提升非常大，为什么会这样？之所以会这样，是因为存在局部性原理，因为程序在执行某条指令后，还有可能再次执行该条指令，频繁不断的执行相同块里面的内容，这称之为**时间局部性**，比方循环语句结构就具备这种特点，如循环体执行100&nbsp;0000次，循环体执行一百万次，循环体之上和之下的语句（如初始化语句和输出语句）往往只执行一次，如果将循环体语句调入到cache中，CPU只需要与cache交互，不需要与内存进行交互，这样就大大提升了效率，速度。
  - 内存与外存之间也有类似的情况，外存里面的数据会先调入到内存。需要运行的程序数据都会先从外存调入到内存。
  - Cache是按内容存取。存信息时考虑信息的内容，不同内容存储到不同的块中，按内容存取的存储器又叫做**相联存储器**，它的速度和效率远高于按地址存取存储器。
  - 引入Cache的目的是提高速度的同时，不增加太多的成本，是性价比方案。

- 内存，也称为主存，容量小，速度快，单位级别是GB,如1G/2G/4G/8G/16GB等。

- 外存，也称为辅存，硬盘、光盘、U盘等。

  

## P14 Cache的基本概念

![](/img/Snipaste_2020-09-04_23-33-46.png)

- Cache是高速缓存。
- Cache高速缓存用来存放当前最活跃的程序和数据，其特点是：位于CPU与主存之间；容量在几千KB和几MB之间；速度一般比主存快5-10倍，由快速半导体存储器构成；其内容是主存局部域的副本，对程序员来说是透明的。
- Cache的功能是提高CPU数据输入输出的速率，突破冯.诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。
- 在计算机的存储系统体系中，Cache是(除寄存器之外)访问速度最快的层次。
- 由于寄存器容量极小，速度极快，并且集成在CPU当中，平时并没有把它当做最顶级的存储器来看待。如果问存储器速度最快的是哪一个？有寄存器的话，选寄存器，没有寄存器话，则选Cache是速度最快的。
- 使用Cache改善系统性能的依据是程序的局部性原理。
- Cache设计的目标是在成本允许的条件下达到较高的命中率。

### 使用Cache+主存存储器的系统的平均周期的计算

使用高速缓存Cache时，CPU首先会在Cache中查找需要的数据，如果找到，则说明命中；如果找不到，则会去内存（主存）中去查找数据，这时称为未命中。

所以可以计算使用高级缓存+主存的平均周期时间：

T<sub>cache+主存</sub> = h * T<sub>cache</sub> + (1 - h ) * T<sub>主存</sub>

如果 Cache访问命中率h为95%的话，Cache的周期时间(或存取时间)为1ns，主存的周期时间(或存取时间)为1000ns的话，则此时的使用高级缓存+主存的平均周期时间计算如下：

T<sub>cache+主存</sub> = h * T<sub>cache</sub> + (1 - h ) * T<sub>主存</sub> = 95% * 1ns + (1- 95%) * 1000ns = 0.95 ns + 50 ns = 50.95 ns

没有引入Cache时，需要1000ns，引入Cache后只需要50.95ns，这时可以看到引入Cache后，速度提升差不多达20倍(19.62倍)。

```sh
$ echo 'scale=2;1000/50.95'|bc
19.62
```



## P15 时间局部性和空间局部性

局部性原理：

- 时间局部性
- 空间局部性
- 工作集理论：工作集是进程运行时被频繁访问的页面集合。

局部性原理到底是怎么一回事，计算机在处理相关的数据和程序的时候，一般都会有在某一个时段集中的去访问某些指令，或在某一个时段集中去读取某些空间的数据，这样的特性，之所以要把这种特性拿出来研究，它对于我们采用多级存储体系，来解决存储的量和速度之间的矛盾的解决方案。我们之前也讲了，速度快的，成本太高，代价太大，所以只能做小容量，而成本便宜的速度又上不去，所以有了局部性原理，我们将它们组合起来，得到最高的性价比。

```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int i,j,s = 0;
    for(i=1; i<1000; i++)
        for(j=1; j<1000; j++)
            s += j;
    printf("结果为:%d\n", s);
    return 0;
}
```

如上面的c代码，第4行初始化语句只执行一次，中间的两个for循环语句，使得里面的`s += j;`将会执行100&nbsp;0000次，这一百万次都不需要从内存里面调数据，只需要从Cache中读取数据，这就是时间局部性。

- 空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。

如对数组进行处理的时候，当程序访问数组A[0]时，马上又访问附近的数据A[1]，A[2]等等。

- 工作集原理就是将被频繁访问的页面集合打包起来，频繁访问可以一起调用进来，短时间不会被替换掉，以此来提高效率。



## P16 随机存储器和只读存储器

主存的分类：

- 随机存取存储器:  Random Access Memory, RAM,即能读取数据也能存入数据的存储器，内存就是随机存取存储器，内存一断断电，内存中所有数据都不会保存下来。
- 只读存储器：Read Only Memory, ROM，断电后只读存储器数据仍然会保存下来。
  - ROM， 固定只读存储器，内容只能读出，不能改变。一般用于存放系统程序BIOS和用于微程序控制。
  - PROM 可编程的只读存储器 Programmable Read Only Memory, 其中的内容可由用户一次性地写入，写入后不能再修改。
  - EPROM 可擦除(Erasable)可编程的只读存储器。
  - EEPROM 电擦除可编程的只读存储器。
  - Flash Memory, 闪存。
- 主存-编码

![](/img/Snipaste_2020-09-05_10-56-06.png)

地址单元计算过程：

- 地址单元数 = 大的地址 - 小的地址 + 1
- 内存地址中最后的H表示16进制，H不参与计算。

所以示例中地址单元数 = C7FFF - AC000 + 1 = C7FFF + 1 - AC000 = C8000 - AC000 = 1C000

```
   C8000
-  AC000
---------
=  1C000

注意：
16进制中 A代表10，B代表11，C代表12
```

1C000 = 1* 16<sup>4</sup> + 12 * 16<sup>3</sup> = 1 * pow(2, 4*4) + 12 * pow(2, 4*3) = pow(2, 6 + 10) + 12 * pow(2, 2+10)

​             = pow(2, 6) * pow(2, 10) + 12 * pow(2, 2) * pow(2, 10)

​             = (64 + 48) * pow(2, 10)

​             = 112 * pow(2, 10)

​             = 112 * 2<sup>10</sup>

所以总共有 112 * 2<sup>10</sup> 字节 个地址单元

转换成KB的话，1kb = 2<sup>10</sup> b

所以共用112 K个地址单元。 



所有的内存地址总的存储容量  = 112K * 16bit

设芯片每个存储单元存储X位，则28片存储芯片的总容量 =  28 * 16K * X

上面的两个值应该相等，即 112K * 16 bit  = 28 * 16K * X

所以X = 112K * 16bit / (28 * 16K) = 4 bit

因此，示例中第1题选B， 第2题选A。   

注意 8bit = 1b (字节)。



## P17 磁盘工作原理

- 磁盘结构与参数

![](/img/Snipaste_2020-09-05_15-19-07.png)

 - 磁盘基本动作的原理，即我们要知道在读取一次数据的过程中，磁盘需要做哪些动作，需要消耗哪些方面的时间，这个是我们需要掌握的。

 - 磁盘是用环线的盘片，上面涂上特殊的材质来保存数据，盘面用来保存数据，读取数据需要专业的设备，就是磁头。

 - 像多碟的磁盘，会有多张盘在里面，每个盘面都会存储一定的信息，要读取信息，磁头先要移动到相应的磁道上，存信息是存在磁道上面。

 - 读信息时，首先要将磁头定位到目标的磁道上面，这个动作需要一定的时间，这个时间称为寻道时间。

 - 旋转延迟时间，又称为等待时间，在一个磁道上面，会分很多扇区，我们存储的数据就在扇区上面，我们需要旋转磁盘，将数据转到磁头下面，这时就可以读取到数据。旋转延迟时间是磁盘转一圈的时间。

 - 最好的情况是直接读取数据，最差的情况是磁盘需要几乎转一圈，所以平均的旋转延迟时间是磁盘转一圈的时间。

 - 教材中介绍：

   	- 为了正确正确地存储信息，将盘片划分成许多同心圆，称为磁道，从外向里编号，最外一圈为0道。
      	- 沿径向的单位距离的磁道道称为道密度。
      	- 将一个磁道沿圆周等分为若干段，每段称为一个扇段或扇区，每个扇区内可以存放一个固定长度的数据块，如512B。
              	- 磁道上单位距离可记录的位数称为位密度。
              	- 因为每条磁道上的扇区数相同，而每个扇区的大小又一样，所以每条磁道都记录同样多的信息。又因为里圈磁道圆周比外圈磁道的圆周小，所以里圈磁道的位密度要比外圈磁道的位密度高。最内圈的位密度称为最大位密度。

简单理解的话，磁盘上面每个磁道上面的存储的数据一样多，虽然里面磁道周长小一些，但里面的磁道与外面的磁盘存储的数据量是一致的，因此这时候里面的位密度就要高一些。

考试示例：

![](/img/Snipaste_2020-09-05_15-49-19.png)

题止目中所说的物理块就是扇区！

绘制一个圆环读取，依次将11个逻辑记录放在圆环上面。

![](/img/Snipaste_2020-09-05_16-36-26.png)

因为磁盘的旋转周期是33ms，而用11个逻辑记录，因此读取一个逻辑记录需要 33ms / 11 = 3 ms。

这也就意味着我们读取一个记录需要消耗3ms。

因为现在磁头在R0的开头的位置，我们此时可以直接读取R0的数据，需要3ms，如果对R0进行处理，也需要3ms。

因为系统使用单缓存区顺序处理这些记录，如果不是单缓存区的话，会存在什么区别？如果是多缓存区的话，我们可以将数据依次读取出来都放在缓存区里面，现在因为是单缓存区，如果我们读取到R0放在缓存区后，这个时候不能不能读取R1数据放在缓存区的，原因是我们对R0进行处理的时候需要3ms时间，必须等到R0处理完成后才能再处理下一个数据。

但是，特别重要的一点是，**在处理R0数据的时候，磁盘并没有停下面，还在匀速的转动，这个时候当R0数据处理完成后，磁头已经不在R1的开头位置，而是R2的开头位置**。

如果要在处理R0后，马上处理R1，则当前磁头需要旋转1圏再加1个逻辑记录，也就是需要使用的时间是 33ms + 3ms ,也就是从开始处理，到处理R0完成后，并将磁头旋转到R1开始的位置，则需要 36ms。

处理R1，R2, ...， R9,这些逻辑记录，也都需要36ms。

最后的R10，因为后面再没有其他的逻辑记录需要处理，因此磁头只需要读取到R10逻辑记录即可，这时需要3ms， 再在缓存区的处理需要3ms，也就是处理R10需要6ms。

因此，总的处理时间 = 36ms * 10 + 6ms = 366ms。



求最小时间，因为我们可以修改逻辑记录的布局。最理想的是，处理完R0时，立即处理R1，也就是将R1放在原来R2的位置，即隔一个逻辑记录放一个新的逻辑记录，因此最后磁盘布局如下：

![](/img/Snipaste_2020-09-05_16-34-29.png)



按这种布局，磁头读取R0后，再在缓存区进行处理后，刚好磁头转到R1的位置，这时经过了3ms + 3ms = 6ms时间（读取3ms，处理3ms），然后接着处理R2、R3、...、R9、R10,每个逻辑记录都需要6ms，因此最小使用时间为11 * 6ms = 66ms。

因此示例中第1题选C 366ms，第2题选B 66ms。

## P18 计算机总线

- 所谓总线(Bus)，是指计算机设备和设备之间传输信息的公共数据通道。
- 总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上。

根据总线所处的位置不同，总线通常被分为三种类型，分别是：

- 内部总线，往往是指微机内部各个外转芯片与处理器之间的总线，是芯片这个级别。
- 系统总线， 是微机中各个插件板和系统板之间的总线，是属于插件板这一层级的，比如我们平常所接触到的PCI、VGA。
  - 具体要进一步了解的是系统总线。系统总线又分为以下三种总线：
  - 数据总线(Data Bus, DB)， 用来传输数据信息的，是双向的，即可以通过DB从内存或输入设备读取数据，也可通过DB将内部数据送到内存或输出设备。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。计算机是32位还是64位的，如果是32位，则计算机的一个字是32个bit位，这说明总线的宽度是32个bit位，则一次能够传输的数据量是32个bit位。
  - 地址总线(Address Bus, AB)， 用于传送CPU发出的地址信息，是单向的。假设地址总线是32位，代表地址总线是2^32次方，即代表4G内存，当有的时候需要将总线作为其他用途的时候，可能就没有这么多可用总线，如果需要用的内存超过4G，则可以考虑使用64位操作系统，否则操作系统管理不了这么多的内存空间的。当然这只是一个举例，因为在系统上面也有这种概念的区分，你的系统之所以能安装64位操作系统，是因为你的硬件/地址总线有这个宽度带支持。 **地址总线的宽度决定了CPU的最大寻址能力** ！
  - 控制总线(Control Bus, CB), 发送控制信息的总线，如控制信息、时序信息和状态信息等，也是双向的。
- 外部总线， 微机与外部设备的总线。



## P19 串联系统与并联系统可靠性计算



- 计算机的可靠性是指从它开始运行(t=0)到某一个时间t这段时间内能正常运行的概率，用R(t)表示。
- 失效率，所谓失效率，是指单位时间内失效的元件数与元件总数的比例，用 lambda  λ 表示。
- 两次故障之间系统能正常工作的时间的平均值称为平均无故障时间MTBF，即 MTBF = 1 / λ 。
- 串联系统可靠性R = R1 * R2 * R3 * ... * RN  ，即需要各个子系统全部正常运行时，系统才可靠。
- 失效率 λ  = λ1 + λ2 + λ3 + ... + λN， 注意这仅是一个简单计算公式，不一定准确，如20个子系统，每个子系统的失效率λ=0.1, 这时按这个公式计算最终整个系统的失效率λ = 0.1 * 20 = 2 = 200 %,而这是不可能的！！！ 这个公式是个近似公式，简化公式，当失效率极低的时候，可以使用这个公式进行计算。

示例，设计算机系统由CPU、存储器、I/O三部分组成，其可靠性分别是0.95、0.90和0.85，求计算机系统的可靠性。

此时计算机的可靠性 R = R1 * R2 * R3 = 0.95 * 0.90 * 0.85 = 0.73

- 并联系统，只要有一个子系统正常工作，系统就正常工作，这样的系统称为并联系统。
- 并联系统的整个系统的可靠性 R = 1 - (1 - R1) * (1 -R2) * (1 -R3) * ... * (1 -RN)
- 在并联系统中只有一个子系统是真正需要的，其余N - 1个子系统为冗余子系统，随着冗余子系统数量的增加，系统的平均无故障时间增加了。

示例，设一个系统由3个相同的子系统构成，其可靠性为0.9，求整个系统的可靠性？

整个系统的可靠性 = 1 - (1 - 0.9) ^ 3 = 0.999

- N模冗余系统，N模冗余系统由N个(N = 2n + 1) 相同的子系统和一个表决器组成，表决器把N个子系统多数相同结果的输出作为系统的输出，通过表决将错误屏蔽掉了，使用这种系统能够提高系统的可靠性。其可靠性可按如下公式计算：

![](/img/Snipaste_2020-09-05_23-48-58.png)

提高计算机的可靠性一般采取如下两项措施：

- 提高元器件质量，改进加工工艺与工艺结构，完善电路设计。
- 发展容错技术，使得在计算机硬件有故障的情况下，计算机仍然能继续运行，得出正确的结果。



## P20 校验码的概念

### 差错控制 - CRC与海明校验码

- 什么是检错和纠错？
  - 检错：检查出错误。
  - 纠错：不断要检查出错误，还需要纠正错误。
  - 要达到检错和纠错，需要增加冗余信息来实现。而在编码的过程中，往往是通过增大码距来实现检错和纠错。

- 计算机系统运行时，为了确保数据在传送过程中正确无误，一是提高硬件电路的可靠性，二是提高代码的校验能力，包括检错和纠错。
- 通常使用校验码来检测传送的数据是否出错。其基本思路是把数据可能出现的编码分为两类：
  - 合法编码，合法编码用于传送数据。
  - 错误编码，错误编码是不允许在数据中出现的编码。
- 码距：一个编码系统的码距是指整个编码系统中任意(所有)两个码字的最小距离。也就是任意两个合法编码之间至少有多少个二进制位不同。
- 例：
  - 若用1位长度的二进制编码，若A=1, B=0，这样A,B之间的最小码距为1。
  - 若用2位长度的二进制编码，若以A=11,B=00为例，A,B之间的最小码距为2。
  - 若用3位长度的二进制编码，可选用111，000作为合法编码，A,B之间的蹑小码距为3。
  - 比如我们要传输A和B这两个数据，若码距为1，正常传输过去的话，A=1,B=0，如果传输后获取的第一个数据是0，这个时候不知道这个0是否是错误的编码，因为0也是合法的，所以此时不知道至道要传输的数据是0还是1。
  - 我们可以使用两位编码来传输，正常传输A=11表示1，B=00表示0,即你要传输1的话，就传输两个1，要传输0的话，就传输两个0，这个时候我们就可以正常发现是否出错错误，如接收到的数据是1100,这时可以发现传输的数据是正确； 如果接收到的数据是1000的话，这时候就发现10是不对的，因为我们约定只能传输11或00,而你传输的是10,不在约定的传输列表中，因此就可以发现10传输是异常的，也就是检错出来了。但这时候并不能纠错，因为不能确定10对应的正确码到底是11还是00，因此此时不能纠错。
  - 我们可以通过再增加码距带进行纠错。假如我们使用3位长度的二进制来编码。即码距为3，用111编码数字1，用000编码数字0。这时候正常接收的编码是 111 000,表示传输了数据1和0。如果我们接收到了 110 000的话，就可以发现 110是一个错误编码，因为111和000是合法编码，这个时候能够正常检错。同时，我们发现110这个错误编码与111这个合法编码更接近，因为我们就可以进行纠错，将110变成111，纠错后获取的数据就是 111 000，也就是需要正常传输过来的数据了。这就说明这时候正常纠错了！

- 码距与检错、纠错有何关系？
  - 在一个码组内为了检测e个误码，要求最小码距d应满足： d >= e + 1
  - 在一个码组内为了纠正t个误码，要求最小码距d应满足: d >= 2t + 1





## P21 校验码-循环校验码CRC

- CRC是指循环冗余校验码（Cyclic Redundancy Check, CRC)。
- 循环冗余校验码由两部分组成： 左边是信息码(数据)， 右边是校验码。
- 我们使用信息码 / 校验码 来看余数是否为0，即是否能够完成整除，如果能够整除，则说明传输的数据是正常的，如果余数非0，则传输的数据是异常的，说明传输过程中出现了错误。
- 上面信息码 除以 校验码 所使用的除法不是普通的除法，而是**模2除法**，与普通除法是有区别的。除数计算的时候使用异或运算（异或：同则为0，不同则为1）。模2除法不向上位借位，直接进行除法异或计算即可。
  - 如100101除以1110，结果得到商为110，余数为1。

示例：

![](/img/Snipaste_2020-09-06_17-56-57.png)

校验码计算示例：原始报文为"110 0101 0101"，其生成多项式为："x^4 + x^3 + x + 1"，对其进行CRC编码后的结果为多少？

解答：

首先要先多项式转成二进制形式的，多项式转成二进制形式为11011。

然后将原始报文左移5 -1 =4位，即生成多项式的长度减1位，多项式长度为5，因此后面补4个0，也就是在原始报文后面被4个0，即变成 110 0101 0101 0000。

然后再使用被0后在数字模2除法除以11011，并计算除数。

|      |      |      |      |      |      |      |      |      |      | 1    | 0    | 0    | 1    | 1    | 1    | 1    | 1    |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 0    | 1    | 1    | 除   | 1    | 1    | 0    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 0    | 0    | 0    |
|      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      | 余   |      |      |      | 1    | 0    | 0    | 1    | 0    |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      | 余   |      | 1    | 0    | 0    | 1    | 1    |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      | 余   |      | 1    | 0    | 0    | 0    | 0    |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      | 余   |      | 1    | 0    | 1    | 1    | 1    |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      | 余   |      | 1    | 1    | 0    | 0    | 0    |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |      | 减   | 1    | 1    | 0    | 1    | 1    |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |      | 余   |      | 0    | 0    | 1    | 1    |      |      |      |

所以将最后的余数0011作为校验码，因此CRC编码为：1100 1010 101 0011。

我们用这个CRC编码除以11011，检查一下结果是否为0 。

这个相对来说比较复杂。我们来个简单一点的计算。



> - 检错计算举例
>
> 实际的CRC校验码生成是采用二进制的模2算法（即减法不借位、加法不进位）计算出来的，这是一种异或操作。下面通过一些例子来进一步解释CRC的基本工作原理。假设： 
>
> (1)设约定的生成多项式为G(x)=x4+x+1，其二进制表示为10011，共5位，其中k=4。 
>
> (2)假设要发送数据序列的二进制为101011(即f(x))，共6位。 
>
> (3)在要发送的数据后面加4个0(生成f(x)*xk)，二进制表示为1010110000，共10位。 
>
> (4)用生成多项式的二进制表示10011去除乘积1010110000，按模2算法求得余数比特序列为0100（注意余数一定是k位的）。 
>
> (5)将余数添加到要发送的数据后面，得到真正要发送的数据的比特流：1010110100，其中前6位为原始数据，后4位为CRC校验码。 
>
> (6)接收端在接收到带CRC校验码的数据后，如果数据在传输过程中没有出错，将一定能够被相同的生成多项式G(x)除尽，如果数据在传输中出现错误，生成多项式G(x)去除后得到的结果肯定不为0。 



我们来计算一下这个例子：

多项式g(x) = x^4 + x + 1，对应的二进制为 10011，即多项式长5位，我们需要在原码后面补5-1 = 4 个0。

原码为 101011，补4个0后，就变成了 10 1011 0000。

再用补0后的数据与10011进行模2除法。



|      |      |      |      |      |      |      |      |      |      | 1    | 0    | 1    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 1    | 1    | 除   | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 0    | 0    | 0    |
|      |      |      |      |      | 减   | 1    | 0    | 0    | 1    | 1    |      |      |      |      |      |
|      |      |      |      |      | 余   |      |      | 1    | 1    | 0    | 1    | 0    |      |      |      |
|      |      |      |      |      |      |      | 减   | 1    | 0    | 0    | 1    | 1    |      |      |      |
|      |      |      |      |      |      |      | 余   |      | 1    | 0    | 0    | 1    | 0    |      |      |
|      |      |      |      |      |      |      |      | 减   | 1    | 0    | 0    | 1    | 1    |      |      |
|      |      |      |      |      |      |      |      | 余   |      |      |      |      | 1    | 0    | 0    |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

所以最后4位是0100，也就是CRC校验码是 0100，CRC编码结果为 1010110100。



再看一个例子：

> 任意一个由二进制位串组成的代码都可以和一个系数仅为‘0’和‘1’取值的多项式一一对应。例如：代码1010111对应的多项式为x^6+x^4+x^2+x+1，而多项式为x^5+x^3+x^2+x+1对应的代码101111。
>
> 假设使用的生成多项式是G(X)=X^3+X+1。4位的原始报文为1010，求编码后的报文。



我们来计算一下。

多项式为g(x) = x^3 + x + 1，转换成对应的二进制就是 1011，多项式长度为4，需要在原始报文后面补充 4 -1 = 3 个0。

因此补0后的报文为 1010 000。

然后再计算模2除法，使用 1010 000 除以 1011。

|      |      |      |      |      |      |      |      | 1    | 0    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    | 除   | 1    | 0    | 1    | 0    | 0    | 0    | 0    |
|      |      |      |      | 减   | 1    | 0    | 1    | 1    |      |      |      |
|      |      |      |      | 余   |      |      |      | 1    | 0    | 0    | 0    |
|      |      |      |      |      |      |      | 减   | 1    | 0    | 1    | 1    |
|      |      |      |      |      |      |      | 余   |      | 0    | 1    | 1    |
|      |      |      |      |      |      |      |      |      |      |      |      |

可以看到最后余数为011，因此将011添加到原始报文后面，就变成了 1010 011。

即CRC校验码为011，最终发送的编码为 1010 011 。

我们验证一下，用 1010 011 除以 1011 看一下结果是否为0：

|      |      |      |      |      |      |      |      | 1    | 0    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    | 除   | 1    | 0    | 1    | 0    | 0    | 1    | 1    |
|      |      |      |      | 减   | 1    | 0    | 1    | 1    |      |      |      |
|      |      |      |      | 余   |      |      |      | 1    | 0    | 1    | 1    |
|      |      |      |      |      |      |      | 减   | 1    | 0    | 1    | 1    |
|      |      |      |      |      |      |      | 余   |      |      |      | 0    |
|      |      |      |      |      |      |      |      |      |      |      |      |

  此时刚好除尽，余数为0，说明我们计算正确。



说明，以上计算过程之所以使用表格形式，主要是为了使各个二进制位对齐，便于计算！



通过上面的例子我们大概的就了解了如何去计算一个信息字段的CRC校验码，可以把求CRC校验码的步骤总结如下：

> 1、将X的最高次幂为R的生成多项式G(X)转换成对应的R+1位二进制数。
>
> 2、将信息码左移R位，相当于对应的信息多项式C(X)*2^R。
>
> 3、用生成多项式（二进制数）对信息码做除，得到R位的余数(注意：这里的二进制做除法得到的余数其实是模2除法得到的余数，并不等于其对应十进制数做除法得到的余数。)。
>
> 4、将余数拼到信息码左移后空出的位置，得到完整的CRC码。



## P22 校验码-海明校验码

- 海明校验码是一种利用奇偶性来检错和纠错的检验方法。
- 海明码的构建方法是的2的幂次位上，如0,1,2,4,8,16,32, ...等等位上面放置校验码。即在数据位的之间的特定位置上插入r个检验位，通过扩大码距来实现检错和纠错。
- k个数据信息位与r个校验位的关系： 2^r - 1 >= k + r
- 理解上面的公式：r个校验位(校验位是0或1)可以表示2^r 种可能，其中只用一种是正常状态，其余 2^r -1种状态表示有错误在某一个位上，而总共有 k + r 位，校验的可能性（异常时）要大于等于所有的位数，因此就有 2^r - 1 >= k + r 。

| 17   | 16   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 位数   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ |
| D11  |      | D10  | D9   | D8   | D7   | D6   | D5   | D4   |      | D3   | D2   | D1   |      | D0   |      |      | 信息位 |
|      | R4   |      |      |      |      |      |      |      | r3   |      |      |      | 2    |      | r1   | r0   | 校验位 |

- k值与r值表格对应关系

| 数据信息位k值 | 校验位r值 |
| ------------- | --------- |
| 1             | 2         |
| 2~4           | 3         |
| 5~11          | 4         |
| 12~26         | 5         |
| 27~57         | 6         |
| 58~120        | 7         |

- 我们要记住以下关系：

| 数据位 | 位与2的幂次方的关系         | 数据位与校验位的关系 |
| ------ | --------------------------- | -------------------- |
| D0     | 3 = 2 ^ 1 + 2 ^ 0           | D与r0、r1有关        |
| D1     | 5 = 2 ^ 2 + 2 ^ 0           | D1与r0、r2有关       |
| D2     | 6 = 2 ^ 2 + 2 ^ 1           | D2与r1、r2有关       |
| D3     | 7 = 2 ^ 2 + 2 ^ 1 + 2 ^ 0   | D3与r0、r1、r2有关   |
| D4     | 9 = 2 ^ 3 + 2 ^ 0           | D4与r0、r3有关       |
| D5     | 10  = 2 ^ 3 + 2 ^ 1         | D5与r1、r3有关       |
| D6     | 11  = 2 ^ 3 + 2 ^ 1 + 2 ^ 0 | D6与r0、r1、r3有关   |
| D7     | 12  = 2 ^ 3 + 2 ^ 2         | D7与r2、r3有关       |

​         

- 通过上表的数据位与校验位的关系，我们可以知道校验位与数据位的关系如下：

| 校验位 | 与校验位相关的数据位 |
| ------ | -------------------- |
| r0     | D0、D1、D3、D4、D6   |
| r1     | D0、D2、D3、D5、D6   |
| r2     | D1、D2、D3、D7       |
| r3     | D4、D5、D6、D7       |

- 计算校验位时的值时，把相关的各个数据位异或(同则为0，不同则为1)求值即可。
  - 所以有以下等式：
  - r0 =  D0 Xor D1 Xor D3 Xor D4 Xor D6
  -  r1 =  D0 Xor D2 Xor D3 Xor D5 Xor D6 
  -  r2 = D1 Xor D2 Xor D3 Xor D7 
  -  r3 = D4 Xor D5 Xor D6 Xor D7

所以按如上公式进行编码，信息数据 0110 1001，有8位数据，此时我们知道需要4位校验码。

| 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 位数           |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------------- |
| D7   | D6   | D5   | D4   |      | D3   | D2   | D1   |      | D0   |      |      | 信息位         |
| 0    | 1    | 1    | 0    |      | 1    | 0    | 0    |      | 1    |      |      | 真实数据       |
|      |      |      |      | r3   |      |      |      | r2   |      | r1   | r0   | 校验位         |
|      |      |      |      | 0    |      |      |      | 1    |      | 0    | 1    | 实际校验位数据 |

所以：

- r0 =  D0 Xor D1 Xor D3 Xor D4 Xor D6    = 1 Xor 0 Xor 1 Xor 0 Xor 1 = 1
-  r1 =  D0 Xor D2 Xor D3 Xor D5 Xor D6   = Xor(1, 0, 1, 1, 1) = 0
-  r2 = D1 Xor D2 Xor D3 Xor D7  = Xor(0, 0,1, 0) = 1
-  r3 = D4 Xor D5 Xor D6 Xor D7 = Xor(0, 1, 1, 0) = 0

将上面的几个校验位填写到表格中，最后获取到海明码为： 0110 0100 1101。

如果实际获取到的海明码是： 0110 0011 1101,这个时候就实际的海明码与正确的海明码异常就可以知道第7位数据是异常的（正常应全为0，非0的则为异常）。



注意：

- 以上操作都是按偶校验进行操作的。
- 如果采用奇校验，则将各校验位的偶校验值取方即可。



## P23 操作系统概述

![](/img/Snipaste_2020-09-11_07-15-52.png)

操作系统基本原理在考试中一般考到7分，比较重要。对于操作系统概念，本身大家不陌生，因为使用计算机，天天都要与操作系统打交道。但是对于操作系统相关的原理，大家平时不会去深入的研究。我们需要展开相关的内容。在讲具体的知识点之前，给大家讲一下操作系统的基本情况。



- 操作系统是用来管理整个系统的软硬件资源的。
- 如果一台计算机买回来后，如果没有安装操作系统，你将无法控制计算机的资源。只有安装了操作系统，你才能操作、控制这些资源。
- 操作系统是人和硬件之间的一种接口。比如说我们可以通过点击鼠标来往硬盘里面存放数据，都要依赖于操作系统。
- 其他的一些应用软件，也是工作在操作系统上的，比如Office应用软件。所以操作系统即是人机接口，也是应用软件与硬件之间的接口。
- 接口往往是命令，比如以前的DOS系统，你需要通过命令来控制系统，往往不那么直观，后来出现了Windows系统，图形化界面比较直观。
- 应用软件和硬件之间的接口是指API接口，指操作系统为应用软件专门提供的API接口，来实现相关的功能。



操作系统具体具备哪些方面的管理也只能：

- 进程管理
- 存储管理
- 文件管理
- 作业管理
- 设备管理



以上五个大的方面都会包含一系列小的知识点。

![](/img/Snipaste_2020-09-11_07-28-09.png)



- 进程管理包含 进程的状态、前趋图、PV操作、死锁的问题。
- 存储管理包含 段页式存储、页面置换算法。
- 文件管理包含 索引文件、位示图。
- 微内核操作系统包含 虚设备与SPOOLING技术等。
- 作业管理与设备管理考得比较少。

## P24 进程状态转换图

![](/img/Snipaste_2020-09-11_07-51-16.png)

- 进程的状态

  - 定义：进程状态是指在操作系统当中，对进程进行管理时，为进程指定了几种状态，以便于给进程分配相应的资源，把它管理起来。

- 进程的状态（三态模型）：

  - 最初的时候把进程分为运行态、就绪态、等待态三种状态。
  - 运行态：进程所需要的所有资源全部配齐了，并且分配了CPU资源，这时候就处于运行状态。
  - 就绪态：指其他的所有资源全部配齐，就是缺少CPU资源，这时候处于就绪态。这是一种万事俱备，只欠东风的状态。
  - 等待态：除了没有CPU资源，还缺少其他资源，比如和外设有交互，等待用户输入指令等，这时候处于等待状态。


- 进程状态的转换：

  - 在运行态，如果缺少某种资源，需要等待某个事件的发生，这个时候就会从运行态转换成等待态。一旦缺少某些资源就进入到等待状态。
  - 如果等待的这些资源现在可以调配过来，这时候等待态可以转换成就绪态。**注意，没有箭头从等待状态指向运行状态。不能从等待态直接转换运行态**。需要重新排队，获取最为核心的CPU资源。
  - 就绪状态排队之后，等待CPU给出调度指令，这时就进入到运行状态。
  - 注意一点，进入到运行状态后，不见得一次性能完成自身的全部任务，因为CPU资源相当宝贵，如果你是一个大的任务，进去之后就完整的占用了CPU资源，别的程序就无法运行。因此采用了**CPU时间片轮转的方案来分配CPU资源**。意思就是一个进程，从就绪到运行态，只能运行一个时间片，等你的时间片用完，即使你的任务还没有完成，你也必须先退出运行态，你得退出运行态，进入到就绪态，等下一次调度，等下一个CPU时间片轮到你的时候才能进入到运行态。
  - 以上是三种状态之间基本转换的原则。

- 细分进程状态及其转换---五态模型
  - 等到三种状态应用比较成熟后，发现其中存在一个问题，就是三种状态不足以含盖常见的各种情况。
  - 比方说，人为地希望将某一个进程暂停、挂起起来，管控起来，这时候用三态模型已经无法做到这一点，所以提出了五态模型。
  - 比原先三态模型多出了**静止就绪态**和**静止阻塞态**。
  - 活跃阻塞态对应三态模型中的等待态（也叫阻塞态、睡眠状态）。
  - 活跃就绪态对应三态模型中的就绪态。
  - 运行态对应三态模型中的运行态。
  - 提出了一种挂起操作。
  - 运行状态挂起时就会进入到静止就绪态，因为这个时候是人为地想把进程搁置起来不处理，进程并不缺少其他的资源，这时就是静止就绪态。
  - 静止就绪态可以恢复或激活，就进入到活跃就绪态，（通俗一点讲，比方说我正在听歌，突然来了个电话，歌声会影响我接电话，我就将歌曲暂停，这就是一个挂起动作，挂起之后，等到我接完电话，我就点击恢复播放歌曲，这个时候就激活了，就进入到活跃就绪态）。活跃就绪态再经过调度就可以运行了。
  - 静止阻塞也可以通过激活到达活跃阻塞（等待态）。



## P25 前趋图

![](/img/Snipaste_2020-09-12_17-20-33.png)

- 前趋图试图解决什么样的问题？
  - 北方人喜欢包饺子吃。包饺子有多道工序，包括A绞肉、B切葱末、C切姜末、D搅拌、E包饺子。
  - 我们要完成包饺子这件事件，可以按顺序方式进行，如果按左侧的A->B->C->D-E，先绞肉再切葱末再切姜末再搅拌再包饺子，这个操作是没有问题的，但平常我们不是这样的，因为大家人多力量大，一般都可以多人一起操作，不需要一个人从头忙到尾，所以这个时候就需要考虑哪些任务是有先后顺序的，哪些任务是可以并行做的。
  - 如果我们按左边的图来表示，就会给人一种误解，只能够先绞肉，再切葱末，再切姜末，这个逻辑就会有问题，所以我们用前趋图的形式来表达的是要完成的一系列的活动的先后约束关系。
  - 比方如通过前面的讲解我们可以了解到绞肉、切葱末、切姜末可以并行的处理，所以将A/B/C放在同样的一条线上，它们之间没有A做完才能做B开始，所以他们之间没有连线，但是必须要完成前面三个活动才能搅拌，所以必须完成A、B、C活动才能开始D活动，因此就有A->D、B->D、C->D的制约关系，D完成之后，才能完成包饺子E的工作。
  - 通过这个图可以直观的看到，哪些任务可以并行，哪些任务有先后关系，这也就是前趋图想表达的东西，这就是前趋图的基本理念。

- 前趋图是一个有向无循环图，由结点和有向边组成，结点代表各程序段的操作（任务），而结点间的有向边表示两个程序段操作（任务）之间存在的前趋关系(-->)。 程序段Pi和Pj的前趋关系表示成Pi->Pj，其中，Pi是Pj的**前趋**，Pj是Pi的**后继**，其含义是Pi执行结束后Pj才能执行。



## P26 进程的同步与互斥

- 同步与互斥是进行PV操作的前提。如果没有理解什么叫做进程的同步，什么叫做进程的互斥，就很难进行PV操作的实际问题。
- 互斥：互斥就是指的在同一时刻，只允许某一个进程去使用资源。同一个资源不能同时服务于多个进程。
  - 比如说千军万马过独木桥，独木桥就是一个资源，不允许很多人同时上独木桥，会出现安全事故。
  - 所以要求人员是一个一个通过的，一个人占用了独木桥资源，其他人得等待，这叫**互斥使用资源**。
  - 如果不是独木桥，而是一个人行天桥，供多人同时使用，那我们认为这是一个**共享资源**。



同步与互斥在PV操作里面，提得非常多，就像一对双胞胎，经常说同步与互斥。请思考一个问题，同步与互斥是不是互为反义词，它们不是反义词。

- 同步的反义词是异步。
- 互斥的反义司是共享。

不要把概念给弄混了。

- 同步：速度有差异，有一定情况下停下等待。
  - 比方说张三步行，李四骑自行车从起点A到终点B（商场），他们从同样的起点到同样的终点，步行速度比较慢，骑自行车速度比较快，如果张三和李四都以全速前进，毫无疑问，李四速度快会先到，这时候他们约定要一起到，这时候李四骑一段时间后，发现超越张三很远了，就停下来等一等，这被称为**同步的过程**。
  - 同步说白了就是有速度匹配的要求，当差距拉得比较大的时候，要求速度快的停下来等一等，这就是同步的过程。



### 进程的同步与互斥

![](/img/Snipaste_2020-09-13_09-09-00.png)

我们来看一下PV操作里面的经典问题，生产者与消费者问题，哪里会存在同步，哪里会存在互斥。



- 首先讨论单缓存区情况
  - 单缓存区情况是市场容量为1，存放了一个东西，就不能存放第二个。
  - 对于市场的操作，不能说既有生产生去存放东西，也有消费者去搬东西，这不允许。同一时刻只允许有一个人进入到市场来进行操作。这就是互斥，市场是一个互斥资源，只允许一个人操作，不能够同时去操作，这就是互斥的问题。
  - 同步的问题：生产者把东西放在市场上去，放了一个后，市场容量为1，此时市场就满了，如果再接着存放一个商品的话，就会产生溢出问题，所以不允许再存放一个商品。只有等到消费者把市场里面的商品拿走消费掉，才允许生产者往市场里面放东西。这个过程与停下来等别人是一回事，生产者要停下来等消费者消费完商品，生产者才能往市场里面存放东西。这就是同步的问题。
- 再来讨论一下多缓冲区情况
  - 多缓冲区情况类似
  - 同步的时候步子迈得大一些。原先只能放一个，现在可以放十个之类的。
  - 现在可以等市场放满后再停下来等消费者消费。

以上就是生产者与消费者里面的同步与互斥的问题。



对于PV操作，必须要分析清楚同步在哪些地方，互斥在哪些地方，你才能够准确的定位哪里要写P操作，哪里要写V操作。



## P27 进程管理-PV操作

需要利用同步与互斥的理念来解决实际的问题，所用到的工具是PV操作。PV操作内容是在整个操作系统部分是最难的部分。

PV操作操作不见得多复杂，就是应用比较灵活。



下面我们来了解相关的概念，并以例题来说明PV操作在整个并发进程系统中起到什么作用。



- 临界资源：进程间需要互斥访问的一些资源，比方说打印机、磁带等。
- 临界区：每个进程中访问临界资源的那段代码称为临界区。通俗一点讲就是临界区是程序代码段，不是缓冲区之类的。
- 信号量：是一种特殊的变量。在PV操作中离不开信号量。应用于PV操作的一种专属变量。



![](/img/Snipaste_2020-09-15_06-54-13.png)

看一下PV操作到底是怎么回事：

- PV操作是两大原子操作的一个组合，有P操作，有V操作。
- P(S)操作：
  - 首先对信号量S进行自减一操作，即（S = S - 1)，如原先S=10,则自减一后S就变成了9。
  - 判断信号量S是否小于0，即 if S < 0：
    - 如果为T(True)，即S<0,则会阻塞当前进程继续执行的状态，把这个进程放到进程队列里面，则会将P(S)这个进程阻塞起来，让这个进程进入到等待状态。
    - 如果为F(False)，如S=0,1,2之类的，会继续向下执行当前程序。
- V(S)操作：
  - 首先对信号量S进行自加一操作，即（S = S + 1)，如原先S=10,则自加一后S就变成了11。
  - 判断信号量S**是否小于或等于**0，即 if S <= 0：
    - 如果为T(True)，即S<=0,则会进程队列里面唤醒一个进程，让它继续执行。
    - 如果为F(False)，会继续向下执行当前程序。
- PV操作本身并不复杂，是将几个简单的操作组合起来。



下面将PC操作带到一个具体的问题当中，看PV操作解决了什么问题。

![](/img/Snipaste_2020-09-15_07-22-31.png)

假设没有PV操作，系统中有两个进程，一个生产者进程，一个消费者进程。生产者负责生产产品，并送到缓冲区，消费者从缓冲区取出产品，并把产品消费掉。

仍然以单缓存区为例，也就是只有一个市场容量的生产者和消费者为例来说明。



最初的时候，市场是空的（缓冲区是空的），这个时候，允许生产者往里面放东西。假设这时候，生产者进程执行，将一个产品放到缓冲区，这个过程没有问题。这个时候如果消费者进程没有运行，生产者进程如果再运行一次，再生产一个产品，再往缓冲区存放产品，因为缓冲区已经有一个产品（缓冲区满了），再放一个产品的话，就会产生溢出问题。

正是由于这个原因，考虑加入PV操作。

上面是生产者进程先执行，这比较片面，也有可能是消费者进程先执行。



如果我们先让消费者进程先执行，想从市场（缓存区）中取出一个产品，但是由于市场刚开始是空的，即没有产品，这个时候如果执行消费者进程，可以发现没有可用的产品，执行也会出问题。



因此可以看到无论从生产者开始执行，还是从消费者进程开始执行，都有可能产生一定的问题。因此就引入了PV操作，来解决这个问题。



下面将PV操作引入进来，看看情况会怎么样：

![](/img/Snipaste_2020-09-15_07-59-03.png)

加入PV操作后，给定了信号量S1和S2的初值，S1初值为1，S2初值为0。我们再按原来的方式执行生产者进程或消费者进程。



首先我们来执行生产者进程：

生产者进程，生产一个产品后，需要执行P操作，P(S1)操作会对S1信号量进行自减1操作，S1 = S1 - 1 = 0，再进行判断，此时S < 0 条件判断为False(因为S1 = 0,不小于0，此时程序不会被阻塞)，因此生产者进程继续向下执行，因此会送产品到缓冲区。再执行V操作，V(S2)操作对S2信息量进行自加1操作，S2 = S2 + 1 = 0 + 1 =1。 这时候的状态是：S1 = 0, S2 = 1。

此时若我们不执行消费者进程，再次执行生产者进程：再生产一个产品，然后执行P操作，P(S1)操作会对S1信号量进行自减1操作，S1 = S1 - 1 = 0 - 1 = -1，再进行判断，此时S < 0 条件判断为True(因为S1 = -1,小于0，此时程序会被阻塞，进入到等待队列)，因此生产者进程会被阻塞，不会继续向下执行。

加入PV操作后，第二次生产的产品不会被送到缓冲区，就不会产生溢出。这种情况可以顺利的执行下去。

有些同学可能会有一定的疑惑，就是咱们把生产者进程阻塞进来了，不能继续往下面执行。如果消费者消费完产品，如何去让生产者知道然后继续执行下去呢？



我们在刚才的生产者阻塞状态下执行消费者进程。此时S1 = -1, S2 = 1 。下面我们看一下消费者进程。

消费者进程先执行P(S2)操作，对S2信号量进行自减1操作，S2 = S2 - 1 = 1 - 1 = 0，再进行判断，此时S < 0 条件判断为False(因为S2 = 0,不小于0，此时程序不会被阻塞)，因此消费者进程继续向下执行，因此会从缓冲区取出产品，此时缓冲区就变成了空的了（表示生产者可以放产品进去）。再执行V(S1)操作，V(S1)操作对S1信息量进行自加1操作，S1 = S1 + 1 = -1 + 1 = 0， 再进行判断，此时S <= 0条件判断为True(因为S1 = 0，小于或等于0，此时就会从等待队列里面将等待进程激活，相当于唤醒生产者进程)。 这时候的状态是：S1 = 0, S2 = 0。



现在从另外一个方面看，如果一开始不运行生产者进程，而直接运行消费者进程。看看情况会怎么样。

即初值S1 = 1, S2 = 0。

执行消费者进程，先进行P(S2)操作，P操作需要对信息量S2进行自减1操作，S2 = S2 - 1 = 0 - 1 = -1，再进行判断，此时S<0条件判断为True(因为S2 = -1，小于0，此时程序会被阻塞）,说明开始时缓冲区是空的，消费者进程不能硬执行，可以看出消费者进程产生的错误也可以用PV操作来避免。



**PV操作所解决的问题，其实是并发进程之间某些约束关系的解决**。因为没加PV操作会存在一些异常，加了PV操作会很好的解决这些问题，所以在以后做题也需要这样进行分析，给你几个进程，走到哪一步需要其他进程进行配合需要P操作来阻塞当前进的状态，使用V操作进行唤醒操作。



## P28 PV操作练习题1



![](/img/Snipaste_2020-09-20_13-12-07.png)

在考试的时候PV操作有一定的难度，考试的时候主要考虑进程间的约束关系，在哪些位置应该要阻塞起来，等待另位的进程进行相关的操作，等待完成后再进行下一步的操作。

这个题有一些的难度，首先来看该书店最多允许N个购书者进入，这要如何实现。在日常中经常遇到，比方如停车场在进入口有一个闸门，显示还有多少停车位，只在当停车场还有车位时，才让新的车辆进入停车场，有车进入时进入P操作，消费资源，否则不让新的车辆进入。只有当有车驶离停车场调用V操作释放资源，才允许新的车辆进入。

P(Sn)/V(Sn) 实现的功能就是允许n个购书者进入书店，有人进入的时候Sn信号量减1，有购书者离开后Sn信号量加1。



购书者付款操作，只有购书者一个人是不能完成的，必须要收银员配合才能完成付款动作。

假设没有a1,a2,b1,b2操作，让收银员进程进行操作，不停的收费，周而复始的收费，但是这是不行的，没有人买书付款是不能收费的，因为没有付款动作，收费是没有意义。因此在b1位置需要一个P操作，而这个P操作需要付款位置的V操作来唤醒收银员进行收费操作。

这个P/V操作需要针对同一个信号量。由于S1/S2/Sn的初值是0、0、n。

由于Sn已经使用了，那么此我我们可以选择信号量S1填写入P( )、V( )操作中，也可以选择S2信号量填写，需要配对，即：

**b1处填写P(S1)，a1处填写V(S1)**。 或者：**b1处填写P(S2)，a1处填写V(S2)**。 

同时，V操作不具备阻塞功能的，比如付款，不是购书者直接把钱甩给收银员就可以立即拿着东西就走，而是需要收银员先进行书的总价的计算以及将书中的磁条处理完成，也就是购书者也有一个阻塞操作，因此a2和b2处也有一对P/V操作，a2处填写P操作，b2处理填写V操作，若之前的操作使用的S1信号量，那么就只我剩下S2信号量了，那么：

**a2处填写P(S2)，b2处填写V(S2)**。  或者： **a2处填写P(S1)，b2处填写V(S1)**。



因此可填写的组合为：

a1： V(S1) ,    a2: P(S2),    b1: P(S1).  b2: V(S2)



或者：

a1： V(S2) ,    a2: P(S1),    b1: P(S2).  b2: V(S1)



所以选择：A,C





从这里可以看到PV操作解题的核心是找出这种约束关系，在这个过程中，不防先进行某个进程会出现什么问题，应该在哪里添加什么约束；假设执行另外一个进程，又会出现什么问题，需要加什么约束，然后加入PV操作能解决这个问题，那么这时候的PV操作就是正确答案了。



## P29 PV操作与前趋图

![](/img/Snipaste_2020-09-20_14-01-54.png)

把前趋图（P25，进行的活动之间的关系）转换成PV操作的形式。

即将前趋图的操作转换成相应的进程，按前趋图的前后顺序执行PV操作。



A/B/C/D/E代表一系列的进程，A、B、C一开始就可以执行，并不受什么约束，D操作必须先完成A、B、C操作，E操作必须先完成D操作。

因此在进程D中增加了三个锁🔒P(Sa)、P(Sb)和P(Sc)，代表A、B、C进程没有完成是不能进行搅拌工作的，因此在A、B、C进程中增加V操作，唤醒D操作中的阻塞的进程，代表只有绞肉(V(Sa))、切葱末(V(Sb))、切姜末(V(Sc))完成后，才能进入后续操作，D完成后(V(Sd))才能进入进程E操作。



我们看一下示例：

![](/img/Snipaste_2020-09-20_14-14-38.png)

在每个箭头处填写信号量，从上到下，从左到右依次填写信号量，像下面的这样的：

![](/img/Snipaste_2020-09-20_14-16-53.png)

因为我们有4个信号量，因此在P3左侧是上: S1信号量， 下: S2信号量，在P3右侧是上: S3信号量， 下: S4信号量

这样更处理更简单。

在箭头的开始(起点)位置需要一个V操作，箭头的结束(终点)位置需要一个P操作。再把箭头对应的信号量写入到PV操作中即可。



因此：

P1位置：起点V(S1)   终点（P3处）需要填写P(S1)。

P2位置：起点V(S2)   终点（P3处）需要填写P(S2)。

P3位置：开始的位置需要填写P(S1)、P(S2)， 因为有两条信号量引出，因此，指向终点（P4处）需要填写V(S3)、指向终点（P5处）需要填写V(S4)。

P4位置：开头位置P(S3) 。

P5位置：开头位置P(S4) 。

最终的选择如下：

![](/img/Snipaste_2020-09-20_14-31-27.png)

这样解决这个问题非常的高效。





## P30 死锁问题

- 进程管理是操作系统的核心，但如果设计不当，就会出现死锁问题。如果一个进程在等待一个不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。
- 所谓死锁，是指两个以上的进程互相都需要对方已经占有的资源导致无法继续运行下去的现象。



给定一定数据的进程，每个进程需要多少资源，计算至少需要多少资源才不会发生死锁。

- 所谓死锁，就是指的系统当中有一系列的资源，有一系列需要用到这些资源的进程，这些进程需要系统分配资源才能运行，如果系统在某一时刻，发现所有的可用资源都已经分配出去了，而所有进程都没有办法完成它本身的职责任务，从而释放已经占有的资源，这就会产生死锁，所有进程都在等待别人给他资源，而自己又不想把自己的资源分享给别人。这样样就造成了系统无法完成一系列任务，就会产生死锁问题。

![](/img/Snipaste_2020-09-20_14-57-25.png)



我们先看一下，哪些情况下就会发生死锁。

假设系统只有5个资源，系统有没有可能发生死锁呢？有可能的，如A进程分配2个资源，B进程分配2个资源，C进程分配1个资源，这个时候系统进程用完了，再没有进程分配给任何一个进程，这时候就死锁了。5个资源有没有可能不发生死锁呢？可能的，如将5个资源全部分配给A进程，此时A进程需要的资源得到的满足，就会执行自己的任务，执行完成后就会释放所占用的资源（5个），依次再把全部的资源给B进程和C进程，这样就不会发生死锁。因此5个资源是有可能发生死锁的。



那假设系统有10个资源，这时候有没有可能发生死锁呢？也是有可能的，如A进程分配4个资源，B进程也分配4个资源，C进程分配2个资源，这时候资源全部分配完成，没有可用资源了，这时候又发生死锁了。即10个资源也可能发生死锁问题。



那假设系统有15个资源，这个时候有没有可能发生死锁呢？因为A、B、C进程每个进程都需要5个资源，我们可以直接给每个进程分配5个资源，分配完成后系统资源用完，但这个时候由于A、B、C所需要的资源都已经满足了，就会去执行自己的任务，执行完成任务后就会将用占用的资源释放掉，这时候系统的15个资源又都空闲了，因此这时候不会发生死锁，即系统有15个资源是不会发生死锁的。



但是题目求的是至少需要多少个资源系统不会发生死锁。即无论怎么分配都不会产生死锁。

我们先给每个资源分配它需要的资源数减一个资源，本例中，给每个进程分配5 - 1 = 4 个资源，这时候每个进程还需要1个资源就可以得到满足，然后释放自己占用的进程，因此我们假设系统还有1个资源。给任何一个进程，假设给A进程，这时候A进程所需要的5个资源全部得到满足，就会执行A进程的任务，执行完成后就会释放A进程占用的5个进程，释放出的资源可以用于其他的进程，这个时候也不会发生死锁，就可以完成所有的任务。因此至少需要 3 * ( 5 - 1 ) + 1 = 13 个资源。



如果有k个进程，每个进程需要n个资源，则不发生死锁至少需要的资源数为：k * ( n -1 ) + 1 。



## P31 死锁的预防和避免以及银行家算法

![](/img/Snipaste_2020-09-20_19-12-07.png)

进程死锁的四个必要条件：

- 互斥：如果不是互斥使用资源，则不存在死锁的问题，所有进程都可以共享资源使用。
- 保持和等待：各个进程会保持自己的资源，并等待别的进程释放更多的资源给自己。
- 不剥夺：系统不会把分配给某个进程的资源剥夺来给其他进程使用。
- 环路等待：如A等B释放资源，B等C释放资源，C又等A释放资源，这样就形成了环路，相互等待，形成了环路等待。

了解到这一点后，发现解决死锁的问题，可以有两种方案：

- 死锁的预防：死锁的预防是通过打破死锁的4个必要条件，打破互斥，打破保持与等待，进行剥夺，强制剥夺别的进程的资源。这种用得比较少，考察得不多。
- 死锁的避免：主要由两种解决方案：如**有序资源分配法**和**银行家算法**。
  - 有序资源分配法：先给A分配资源，再给B分配资源，再给C分配资源，再给D分配资源，依次类推，这样可以发现资源的利用率比较低，更加灵活有效的方法是使用银行家算法，
  - 银行家算法：银行家算法在考试中考察频度较高。银行家算法的基本思想是以银行放贷的思路来做资源分配。对于银行家而言，他的资源就是钱，他放贷出来，他要考虑这个资源能不能按时收回来，如果评估发现这个资源（钱）放出去后收不回来，银行家就不会去放这笔贷款。
- 银行家算法：
  - 银行家算法分配资源的原则：
    - 当一个进程对资源的最大需求量不超过系统中的资源时可以接纳该进程。
    - 进程可以分期请求资源，但请求的总数不能超过最大需求量。
    - 当系统现有的资源不能满足进程尚需资源时，对进程的请求可以推迟分配，但总能便进程在有限的时间里得到资源。
- 系统状态：
  - 安全状态：系统能按某种顺序来为每个进程分配其所需资源，直到最大需求，使每个进程都可顺序完成，不发生死锁，则称这个顺序为安全序列，也就是系统是处于安全状态。
  - 不安全状态：不存在安全序列，也就是系统会发生死锁现象，这个就是系统处于不安全状态。

具体由一个实例来分析。

![](/img/Snipaste_2020-09-20_19-41-40.png)



| 进程\资源              | 最大需求量         | 已分配资源数       | 剩余资源数       | 还需要资源数       |
| ---------------------- | ------------------ | ------------------ | ---------------- | ------------------ |
|                        | R1     R2     R3   | R1     R2     R3   | R1     R2     R3 | R1     R2     R3   |
| P1                     | 6        5       2 | 1        2       1 |                  | 5        3       1 |
| P2                     | 2        2       1 | 2        1       1 |                  | 0        1       0 |
| P3                     | 8        1       1 | 2        1       0 |                  | 6        0       1 |
| P4                     | 1        2       1 | 1        2       0 |                  | 0        0       1 |
| P5                     | 3        4       4 | 1        1       3 |                  | 2        3       1 |
| 初始状态总计分配资源数 |                    | 7        7       5 |                  |                    |
| 初始状态剩余可用资源数 |                    | 2        1       0 |                  |                    |

说明：

- 初始状态总计分配资源数 = 已分配资源数的和
- 初始状态剩余可用资源数 = 总可用资源数 - 初始状态总计分配资源数
- 总可用资源数：R1 = 9, R2 = 8, R3 = 5。
- 初始状态即T0时刻。

我们进行一轮计算，看先执行那个进程，初始状态可用资源是：

R1 = 9 - 7 = 2

R2 = 8 - 7 = 1

R3 = 5 - 5 = 0

可以看到R3没有可用资源了，所以第1步不能执行P1/P3/P4/P5，因为这个时候这些进程都需要R3资源，仅P2不需要R3资源，需要先执行P2操作。

因此可排除A和D选项，只能在B和C选项中选择正确答案。 



那么我们第1步先执行P2进程，给P2进程分配资源。P2还需要1个R2资源，把剩余可用资源R2分配给P2后，剩余可用资源为：

R1 = 2 , R2 = 0, R3 = 0。

这时进程P2顺利执行，执行完成后，释放P2占用的资源，R1 = 2 , R2 = 2, R3 = 1。

执行完成P2后剩余的可用资源数为：

R1 = 2 + 2 = 4 , R2 = 0 + 2 = 2, R3 = 0 + 1 = 1。

我们检查P1/P3/P4/P5进程，若分配R1资源，只有4个R1资源，此时不能给P1和P3分配足够的资源，因为P1还需要5个R1资源，5 > 4，P1得不到满足，会进入到不安全状态，因此C选项排除。那么只能选择B选项，正常答案是B选项。同样P3进程需要6个R1资源，6 > 4，P3也不能得到满足，即P2执行完成后不能执行P1和P3进程，相关的选项也需要排除掉。我们同样可以检查一下R2资源，P2执行完成后R2资源只剩下2个，此时P1和P5都需要3个R2资源，因些也不能执行P1和P5，因此P2->P1,P2->P5的选项也需要排除。那么P2执行完成后只能执行P4进程。

现在我们来检查一下B选项是不是一个安全序列：

| 进程\资源 | 最大需求量         | 已分配资源数       | 可用资源数         | 执行完当前进程剩余资源数 | 还需要资源数       | 执行顺序 |
| --------- | ------------------ | ------------------ | ------------------ | ------------------------ | ------------------ | -------- |
|           | R1     R2     R3   | R1     R2     R3   | R1     R2     R3   | R1     R2     R3         | R1     R2     R3   |          |
| P1        | 6        5       2 | 1        2       1 |                    |                          | 5        3       1 |          |
| P2        | 2        2       1 | 2        1       1 | 2        1       0 | 4         2        1     | 0        1       0 | 第1步    |
| P3        | 8        1       1 | 2        1       0 |                    |                          | 6        0       1 |          |
| P4        | 1        2       1 | 1        2       0 |                    |                          | 0        0       1 |          |
| P5        | 3        4       4 | 1        1       3 |                    |                          | 2        3       1 |          |

执行完成当前进程剩余资源数 = 可用资源数 + 已经分配资源数。

执行完成P2后，再执行P4进程：

| 进程\资源 | 最大需求量         | 已分配资源数       | 可用资源数          | 执行完当前进程剩余资源数 | 还需要资源数       | 执行顺序 |
| --------- | ------------------ | ------------------ | ------------------- | ------------------------ | ------------------ | -------- |
|           | R1     R2     R3   | R1     R2     R3   | R1     R2     R3    | R1     R2     R3         | R1     R2     R3   |          |
| P1        | 6        5       2 | 1        2       1 |                     |                          | 5        3       1 |          |
| P2        | 2        2       1 | 2        1       1 | 2        1       0  | 4         2        1     | 0        1       0 | 第1步    |
| P3        | 8        1       1 | 2        1       0 |                     |                          | 6        0       1 |          |
| P4        | 1        2       1 | 1        2       0 | 4        2        1 | 5          4        1    | 0        0       1 | 第2步    |
| P5        | 3        4       4 | 1        1       3 |                     |                          | 2        3       1 |          |

此时，再在P1、P3、P5中选择一个进程进行下一步执行，因为P3需要6个R1资源，而剩余的R1资源数5，P3得不到满足，会发生死锁问题，因此不能执行P3进程，可以执行P1或P5进程。



若先执行P1操作：

| 进程\资源 | 最大需求量         | 已分配资源数       | 可用资源数          | 执行完当前进程剩余资源数 | 还需要资源数       | 执行顺序 |
| --------- | ------------------ | ------------------ | ------------------- | ------------------------ | ------------------ | -------- |
|           | R1     R2     R3   | R1     R2     R3   | R1     R2     R3    | R1     R2     R3         | R1     R2     R3   |          |
| P1        | 6        5       2 | 1        2       1 | 5        4       1  | 6         6       2      | 5        3       1 | 第3步    |
| P2        | 2        2       1 | 2        1       1 | 2        1       0  | 4         2        1     | 0        1       0 | 第1步    |
| P3        | 8        1       1 | 2        1       0 |                     |                          | 6        0       1 |          |
| P4        | 1        2       1 | 1        2       0 | 4        2        1 | 5         4        1     | 0        0       1 | 第2步    |
| P5        | 3        4       4 | 1        1       3 |                     |                          | 2        3       1 |          |

此时，再在P3、P5中选择一个执行，若先执行P3,因为剩余资源是：R1 = 6, R2 = 6, R3 = 2,此时能满足P3的需求，若第4步执行P3,执行完成后释放资源，剩余资源数是：R1 = 6 + 2 = 8, R2 = 6 + 1 = 7, R3 = 2 + 0 =2，最后再执行P5进程，资源数也是满足的，执行完成P5进程后，剩余资源数是：R1 = 8 + 1 = 9， R2 = 7 + 1 = 8, R3 = 2 + 3 = 5。 此时资源全部被释放出来了，与可用资源数完全一样。

所以P2 -> P4 -> P1 -> P3 -> P5 是一个安全序列。同样P2 -> P4 -> P1 -> P5 -> P3也是一个安全系统。



若执行P2->P4进程后，先执行P5进程：

| 进程\资源 | 最大需求量         | 已分配资源数       | 可用资源数          | 执行完当前进程剩余资源数 | 还需要资源数       | 执行顺序 |
| --------- | ------------------ | ------------------ | ------------------- | ------------------------ | ------------------ | -------- |
|           | R1     R2     R3   | R1     R2     R3   | R1     R2     R3    | R1     R2     R3         | R1     R2     R3   |          |
| P1        | 6        5       2 | 1        2       1 |                     |                          | 5        3       1 |          |
| P2        | 2        2       1 | 2        1       1 | 2        1       0  | 4         2        1     | 0        1       0 | 第1步    |
| P3        | 8        1       1 | 2        1       0 |                     |                          | 6        0       1 |          |
| P4        | 1        2       1 | 1        2       0 | 4        2        1 | 5          4        1    | 0        0       1 | 第2步    |
| P5        | 3        4       4 | 1        1       3 | 5        4       1  | 6         5        4     | 2        3       1 | 第3步    |

执行完成P5后剩余资源数：R1 = 5 + 1 = 6, R2 = 4 + 1 = 5, R3 = 1 + 3 = 4。此时随便执行P1或P3都可以，若先执行P1，执行完成P1后剩余资源数：R1 = 6 + 1 = 7, R2 = 5 + 2 = 7, R3 = 4 + 1 = 5。最后再执行P3，执行完成P3后剩余的资源数： R1 = 7 + 2 = 9, R2 = 7 + 1 = 8, R3 = 5 + 0 = 5，与总可用资源数相同，说明全部资源都释放出来了。

因此，又可以得到两个安全序列：

P2 -> P4 -> P5 -> P1 -> P3

P2 -> P4 -> P5 -> P3 -> P1



因此，所有的安全系列有：

P2 -> P4 -> P1 -> P3 -> P5 

P2 -> P4 -> P1 -> P5 -> P3

P2 -> P4 -> P5 -> P1 -> P3

P2 -> P4 -> P5 -> P3 -> P1

题目中只有B选项满足要求，所以选择B。

我们在考试的时候，只用去验证各个流程是否满足要求，不满足要求的序列就是不安全序列，可能发生死锁。



## P32 分区存储组织

![](/img/Snipaste_2020-09-20_23-42-38.png)

存储这一块，我们之前在组成原理这个章节已经讲到了某些内容，如Cache、内存、磁盘等基本情况，下面我们从软件层面来考虑存储管理的机制。

首先看到的是不同的存储管理的分配算法。这个分配算法在是什么样的场景下进行应用的呢？

就是我们有一个存储区域，这个存储区域除了给系统用，也有给用户用的内存空间，这个空间原来是一块连接的大的空白区域，等到用户程序用时，系统就会把用户需要的大小提交到分配的组织里面去，然后给它分配需求匹配大小容量的内存，比方如作业需要33k的内存，作业2需要22k的内存，系统就给它分配22k的内存。

作业1与作业2之间为什么会间隔25k的空白空间呢？主要原因是作业1位置有个33k的程序，有可能刚好有一个程序需要25K的空间，系统就给这个程序分配了25k的内存空间，这个程序执行完成后就释放出25k的空白空间。

在这种体制当中，存储空间是动态分配的，你需要用多少，我就给你分配多少。分配过程中又要进一步考虑很细致的问题。现在我要给作业4分区内存空间，需要9k的内存，现在整个系统中有多个空间块，如25k,28k,10k，我要给作业4分配9k的空间，到底从哪个空白区位置进行切割呢？到底放在哪个区域里呢？这要由相应的算法决定。

下面看一下这几种算法：

- 首次适应算法：系统从内存的低地址开始选择一个能装入作业的空白区。即从内存位置0处开始向高地址找第一个合适的区域，只要能装入就分配给作业空间。
  - 在我们的示例中，现在有三块可用的空白内存空间区域，内存地址从小到大排列的可用空白内存空间区域分别是25K、28K和10K，现在我们只需要9K，按首次适应算法，只需要在25K区域（25k > 9k,大小满足要求）分配一个9K内存空间出来给作业4即可，这时第1个空白区域就剩下 25 - 9 = 16K的空白内存空间区域。
- 最佳适应算法：把系统中所有剩余的可用空白内存空间按大小顺序连成一个链，从小到大排列，首先用最小的可用空白空间与作业需要作用的内存比较，如果刚好满足（可用空间内存 >= 作业需要的内存空间），则将这个最小的内存可用空间分配给该作业。
  - 如我们示例中，内存中可用空白内存空间区域分别是25K、28K和10K，将空白区域从小到大排列连成一个链，即10K、25K、28K，然后我们需要分配9K的空间，因为最小的空白区域10K已经满足要求(10k >= 9k)，因此会在10K的空白空间分配9K的空间给作业4，剩余1K的空白空间。如果我们需要分配15K的空间，因为最小的空白区域不满足要求(10K < 15K)，因此需要在第二个最小的空间25K区域去分配空间(25K >= 15K)，这样25K的空白区域切割15K空间出来后，就剩下10K的空白空间。
  - 使用最佳适应算法能保留较大的空白区，但是存在一个缺点是随着系统不断的释放空间，可能会产生大量无法再继续分配的无用小分区（称为外碎片），如上面在10K区域分配9K给作业4后，只剩下1K的空间，这个空间太小极有可能无法再分配给其他的程序使用，就会存在碎片。
- 最差适应算法：与最佳适应算法相反，是在所有可用空白空间中选择最大的空间来切割分配给新的作业。这种方式不容易产生外碎片。
  - 如我们示例中，内存中可用空白内存空间区域分别是25K、28K和10K，将空白区域从小到大排列连成一个链，即10K、25K、28K，然后我们需要分配9K的空间，按最差适应算法，我们需要在最大的空白空间里面进行切割，也就是在28K的区域分配一个9K的空间出来，这样分配后，28K区域的位置还剩余28 - 9 = 19K的空白空间，这样就不易产生比较小的碎片了。
- 循环首次适应算法：把空闲的空白空间连成一个环状，每次分配都是从刚分配的空白区域开始寻找一个能满足用户要求的空白区。
  - 如我们示例中，内存中可用空白内存空间区域分别是25K、28K和10K，将这三个空白区域组成一个环状 25K --> 28K --> 10K -->25K。。。如我们依次分配了作业1、作业2、作业3的空间，，循环均匀匹配分配，由于作业3刚好在28K空间附近进行分配，我们分配作业4时就从28K空间开始分配，这是分配9K空间出来，剩余19K的空白空间。





## P33 页式存储、段式存储、段页式存储

下面我们看到的是段页式存储，段页式存储在操作系统中的应用十分的广泛。基本上现在所有的操作系统都会支持这种机制。段页式存储需要我们掌握的有：

- 页式存储中逻辑地址与物理地址的转换。
- 页式存储、段式存储、段页式存储的基本特点以及运作的基本方式。

![](/img/Snipaste_2020-09-25_06-24-41.png)



### 页式存储

为什么要提出页式存储方案：之前我们讲了分区存储组织，分区化的管理，我们在内存中划定用户区域，用户区域是供用户程序调入内存时使用的，这种管理方式往往是将用户程序整体调入内存，这也就意味着，如果内存空间是4G大，用户空间2G的话，这时候如果要运行2G以上的程序就完全不可能的，甚至还不需要运行2G程序，有可能运行1G程序也可能出问题，因为在内存当中，运行的时候，空间被打碎，不是连续的空间，这时候虽然空闲空间有1个G大，但不是连接的，虽然这时候空闲区加起来有1个G大，但不能运行1个G的程序，因为这时候不能一次性装入。为了解决这个问题，我们提出了段、页式存储的基本思路。

- 页式存储
  - 把用户程序分成等分大小的页，比如将用户程序等分为4K一个块的区域，每个4K的块称为页。把内存中存储区也划分为4K大小的若干个物理块，称为块或页框。
  - 我们要调入程序到内存中运行的时候，不再是将程序整个调入到内存当中。采取的机制是要运行哪些块，就调入哪些块，把哪些页入调入进来。这样就需要有一个页表来记录他们之间的对应（映射）关系，用户程序的多少号页对应内存当中的多少号块。
  - 采用这种方式，就可以解决掉超越内存容量的程序运行的问题。比如内存是2G，甚至可以运行4G大小的用户程序。用户要用到哪些程序页，就调入哪些程序页，已经用完的程序页，就调出内存。
  - 优点：利用率高，碎片少，分配和管理简单。
  - 缺点：增加了系统的开销，可能产生抖动现象。
  - 这种方式有多方面的优点：内存利用率高，因为我们把内存分存4K大小的块，不能利用的只是块内的某一小块空间，比如我们程序是102K，就需要分配26个页 （26 * 4K = 104K），最后一个页只有2K的程序，但分配了4K的页，就有2K的空间被浪费掉。只要是有4K大小的容量的话，基本上都会被利用上。这样一来碎片就非常少，利用率高。这是它的优点。
  - 但这种方式也有显著的缺点，缺点就在于增加了系统的开销，可以产生抖动的现象。有一个页表，页表记录了两者之前的链接关系（映射关系），也就意味着，我们要执行某个程序的时候，要定位具体的代码，需要通过查表来准确定位，不像之前是连接的空间，不需要通过映射表来调到相应的内存块，页式需要进行这种转换，转换无疑增加了系统的开销，先读取页表，再读取页表的页号查找块号，这样就耗时一些。可能产生抖动现象（分配较多资源时，出现缺页的可能性可能更大）。
  - 在页式存储中考察得比较多的是逻辑地址与物理地址之间的转换。
  - 逻辑地址与物理地址之间很多地方是相同的，比如页内地址是一样的！页号不一样，逻辑地址的页号对应物理地址的块号，一般是不相等，但可以做到相等，如0号页对应0号块，1号页对应1号块。也可以做到不相等，如0号页对应2号块之类的。因为没有严格的限制。页号和块号需要通过查表来得知。至于页内地址是一样的，因为调入的时候是以页为单位，以页为单位的偏移量不会有变化。
  - 要如何通过逻辑地址来求物理地址呢？首先要知道逻辑地址哪一部分是页号哪一部分是页内地址。知道哪一部分是页号，哪一部分是页内地址，则直接将页内地址记录下来，是物理地址的页内地址(A，然后通过页号在页表中查找对应的块号(B)，最后将查找到的块号与页内地址拼接(BA)起来就可以了，就样就得到了物理地址。

下面看一个示例，来看一下逻辑地址与物理地址之间的转换：

![](/img/Snipaste_2020-09-25_07-25-35.png)

我们来看一下分析过程，分析如下：

要求物理地址，首先要将逻辑地址中的页号与页内地址分开，如何分开呢？我们要通过页面大小（4K）参数来分析得知，页面大小4K，4K写成二进制，4K = 4 * 2^10 = 2^12，表示2的12次方，对应有12个2进制位，说明页内地址是12位，高于12位的就是页号，二进制每四个位对应一个十六进制位，一个十六进制位对应4个二进制位。所以12个二进制位就对应3个十六进制位，即对应5A29H中的A29，注意十六进制最后的H不参入计算，H用来表示是十六进制，因此页内地址就是A29，页号是5。可以看到备选答案中，末3位都是A29，就说明页内地址不需要我们求的。页号是5，对应的物理块是是多少呢？**物理块号有多种叫法，有时候又叫它页帧号**，所以通过查表可知逻辑块号5对应的物理块号是6，因此最后拼接后的物理地址是6A29H，因此选择D。

如果进程P要访问的页面4不在内存里面，那么应该淘汰哪个页面呢？淘汰只能淘汰在内存的页面，状态位表示在不在内存中，状态位为1表示在内存中，即页面0、1、2、5在内存中，只能从这几个页面中选择一个进行淘汰。选择哪一个淘汰，则需要看访问位，访问位为1的不能被淘汰，只有访问位是0的才能被淘汰，因为刚刚被访问过的有可能会被程序继续访问到（程序局部性原理）。因为只有1号页面的访问位是0，所以我们淘汰1号页面，因此选择B。	

### 段式存储

![](/img/Snipaste_2020-09-29_06-42-30.png)

段式存储包括段号和段内地址两个部分。

这样子看起来，觉得与页式存储好像是一样的，只是把名字改了一下。实际上不是这么回事。

段式和页式存储的分隔方式有较大差别。

段式存储是按逻辑结构来进行划分的。意思就是一个程序当中，会将main主函数做为一个段，function1做为一个段，function2做一个段，...，段的大小不要求一致，有的段是40K，有的段是80K,有些是150K...，这都是可以的。但这在页式存储中是不允许的，规定的页是4K大小的话，每个页就只能是4K大小，不能有区别。而段式存储中段就没有这个限制，可以有区别，有的段长，有的段短。

按段式逻辑来划分，最大的好处就是便于共享。

相对来话，内存利用率低一些，内存碎片浪费大一些，因为要按段的大小在内存中切相应的区块来完成任务。



段表存的是段号、基地址，段长。 基地址称为基地，指这个段是从内存中哪个地址开始，即起始地址。



### 段页式存储

![](/img/Snipaste_2020-09-29_06-58-53.png)

段页式存储是将页式存储和段式存储结合起来，先分段，再分页，是典型的中庸之道的产出，它的优点是集合了段式存储和页式存储的优点。

优点：空间浪费小，存储共享容易。

缺点：增加了软件的复杂度，开销增大，速度降低。因为要先查段表，然后再查页表。



### 快表

![](/img/Snipaste_2020-09-29_07-04-16.png)

快表是一块小容量的相联存储器（按内存存储，速度非常快，效率非常高），由高速缓存器组成（即快表放在Cache中），速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。

查找联想存储器和查找主存页表是并行进行的，一旦在联想存储器（即相联存储器）中找到相符的逻辑页号，就停止在查找主存页号。

相对来说，将页式存储中页表、段式存储的段表放在内存中，这种称为**慢表**。



## P34 页面淘汰算法



![](/img/Snipaste_2020-09-29_07-15-31.png)

页面置换算法广泛应用于分层存储体系当中。比如之前讲的cache,cache数量有限，当cache数据块都被占用了，要调入到新的块进来时，就要涉及到页面置换的问题。在内存体系这一块也一样，同样页面这样的问题。比方如页式存储当中，一个程度有100个，但是内存可以分配的页是有限的，比方只有3个页，这个时候就不可避免的在程序运行过程中，要把不用的页调出来，把现在需要用到的页调入进去。这要依据一定的算法进行识别，哪些页淘汰是比较好的，这就涉及到页面淘汰算法。

页面淘汰算法，比较有代表性的有以下几种：

- 最优（Optimal，OPT）算法
- 随机（Random）算法
- 先进先出（FIFO）算法，有可能产生抖动现象。例如，432143543215序列，使用3个页面比用4个页面缺页次数少。
- 最近最少使用（LRU）算法。不会产生抖动现象。

这几种算法，在考试中比较容易出现的是先进先出算法和最近最少使用算法。

因为前面两种算法：

- 随机算法随机的淘汰一个，性能是不稳定的。
- 最优算法，是一种理论层面的页面淘汰算法， 是在整个事件发生之后，即我们知道我们的访问的系列是怎么样的，而且根据系列来分析算出在什么时间点淘汰什么页面能够取得最高的效率性能，就把这个作为最优算法。它针对每个实际场景，最优算法往往是不一样的，没有普遍的规律。而且由于在实际使用过程中，往往没有办法从整体上面来了解需要访问的页面顺序到底是怎么样的，因为比如说，涉及到分支，需要根据条件来判断，不知道下一个页面到底要访问哪一个，整个完整的系列是排不出来的。所以最优算法，在实际应用中，是没有办法直接应用的。它的应用方式是怎么样的呢？就是把最优的写出来，再把它与其他算法方案对比，看看其他算法的差距有多大，往往是起到这样的作用，用来评估其他算法。

需要重点关注的算法：

- 先进先出算法：First In First Out，先进先出的基本思路很简单，要淘汰内存页面时，看哪个页面最先进入内存，最先进入内存的页面最先被淘汰。先进先出算法有可能产生抖动现象：分配更多的资源，希望将事件做得更好，但实际上有可能效率降低了，缺页次数变多，如示例中当分配的物理块从3块增加到4块时，有缺页次数增加，缺页率提高的异常的现象。
- 最近最少使用算法：Least Recently User，最近最少使用算法不会产生抖动现象，分配的资源越多，表现的性能越好。刚刚被访问的不会被淘汰出去，由于存在局部性原理，刚刚被访问到的页面有可能马上又会被访问到，因此不会被淘汰。

下面看示例。

首先，看一下先进先出算法：

![](/img/Snipaste_2020-09-30_06-44-50.png)

表中第一行代表需要访问的页面资源序列，第一列代表内存中的三个物理块页面，首先这三个物理块是空的。

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 2                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 3                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 是否产生缺页        |      |      |      |      |      |      |      |      |      |      |      |      |

刚开始是这样的，1、2、3物理块都是空的，要访问4号页面资源，由于内存物理块中没有4号页面资源，产生一次缺页，我们将4号页面资源放到物理块1中，放入后表中数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    |      |      |      |      |      |      |      |      |      |      |      |
| 2                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 3                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 是否产生缺页        | Yes  |      |      |      |      |      |      |      |      |      |      |      |

然后，我们需要访问3号页面资源，由于内存物理块中没有3号页面资源，产生一次缺页，我们将3号页面资源放到物理块2中，放入后表中数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    |      |      |      |      |      |      |      |      |      |      |
| 2                   |      | 3    |      |      |      |      |      |      |      |      |      |      |
| 3                   |      |      |      |      |      |      |      |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  |      |      |      |      |      |      |      |      |      |      |

然后，我们需要访问2号页面资源，由于内存物理块中没有2号页面资源，产生一次缺页，我们将2号页面资源放到物理块3中，放入后表中数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    |      |      |      |      |      |      |      |      |      |
| 2                   |      | 3    | 3    |      |      |      |      |      |      |      |      |      |
| 3                   |      |      | 2    |      |      |      |      |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  |      |      |      |      |      |      |      |      |      |

接着我们需要访问1号页面资源，这时候内存物理块中没有1号页面资源，产生一次缺页。这个时候三个内存物理块都被占用了，为了能够访问1号页面资源，必须要淘汰一个页面用于存放1号页面资源。根据先进先出算法，先进入内存的页面先被淘汰。我们知道4号页面资源先进入到内存中并放到物理块1中，因此我们需要将物理块1上面的4号页面资源淘汰掉，然后把1号资源装入到1号物理块中，放入后表中的数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    |      |      |      |      |      |      |      |      |
| 2                   |      | 3    | 3    | 3    |      |      |      |      |      |      |      |      |
| 3                   |      |      | 2    | 2    |      |      |      |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  |      |      |      |      |      |      |      |      |

接着我们需要访问4号资源，可以看到我们刚把4号资源淘汰后又要访问4号资源，这就是一个问题。我们接着按先进先出算法来淘汰一个页面。现在内存物理块中存在1号、3号、2号页面资源，3号页面是先进入到内存中，因此要淘汰2号物理块上面的3号页面资源，并把4号页面资源存放到2号物理块中，放入后表中的数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    |      |      |      |      |      |      |      |
| 2                   |      | 3    | 3    | 3    | 4    |      |      |      |      |      |      |      |
| 3                   |      |      | 2    | 2    | 2    |      |      |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  |      |      |      |      |      |      |      |

接着我们需要访问3号资源，可以看到我们刚把3号资源淘汰后又要访问3号资源，这就是一个问题。我们接着按先进先出算法来淘汰一个页面。现在内存物理块中存在1号、4号、2号页面资源，2号页面是先进入到内存中，因此要淘汰3号物理块上面的2号页面资源，并把3号页面资源存放到3号物理块中，放入后表中的数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    |      |      |      |      |      |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    |      |      |      |      |      |      |
| 3                   |      |      | 2    | 2    | 2    | 3    |      |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |      |      |      |      |      |      |

接着我们需要访问5号资源，我们接着按先进先出算法来淘汰一个页面。现在内存物理块中存在1号、4号、3号页面资源，1号页面是先进入到内存中，因此要淘汰1号物理块上面的1号页面资源，并把5号页面资源存放到1号物理块中，放入后表中的数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    |      |      |      |      |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    |      |      |      |      |      |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    |      |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |      |      |      |      |      |

接着我们需要访问4号资源，由于4号页面资源在2号物理块中，可以直接访问，不会产生缺页，访问4号页面数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    |      |      |      |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    |      |      |      |      |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    |      |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | No   |      |      |      |      |

接着我们需要访问3号资源，由于3号页面资源在3号物理块中，可以直接访问，不会产生缺页，访问3号页面数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    |      |      |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    |      |      |      |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    |      |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | No   | No   |      |      |      |

接着我们需要访问2号资源，现在内存物理块中存在4号、3号、5号页面资源，此时内由于2号页面资源不在内存中，产生一次缺页，4号页面是先进入到内存中，因此要淘汰2号物理块上面的4号页面资源，并把2号页面资源存放到2号物理块中，访问2号页面数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    | 5    |      |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 2    |      |      |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    |      |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | No   | No   | Yes  |      |      |

接着我们需要访问1号资源，现在内存物理块中存在3号、5号、2号页面资源，此时内由于1号页面资源不在内存中，产生一次缺页，3号页面是先进入到内存中，因此要淘汰3号物理块上面的3号页面资源，并把1号页面资源存放到3号物理块中，访问1号页面数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    | 5    | 5    |      |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 2    | 2    |      |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 1    |      |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | No   | No   | Yes  | Yes  |      |

接着我们需要访问5号资源，由于5号页面资源在1号物理块中，可以直接访问，不会产生缺页，访问5号页面数据如下：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    | 5    | 5    | 5    |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 2    | 2    | 2    |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 1    | 1    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | No   | No   | Yes  | Yes  | No   |

因此可以看到，访问12次页面资源，产生了9次缺页，缺页率f = 9 / 12 = 75%。



如果我们有4个物理块的话，看看先进先出会产生多少次缺页。

按上面3个物理块资源的方式我们一次性的计算出访问各页面资源序列是否缺页：

| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1                   | 4    | 4    | 4    | 4    | 4    | 4    | 5    | 5    | 5    | 5    | 1    | 1    |
| 2                   |      | 3    | 3    | 3    | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 5    |
| 3                   |      |      | 2    | 2    | 2    | 2    | 2    | 2    | 3    | 3    | 3    | 3    |
| 4                   |      |      |      | 1    | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | No   | No   | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |

可以看出，访问12次页面资源，产生了10次缺页，只有2次没有缺页，缺页率f = 10 / 12 = 83.3%。



注意，我这边表中的填写内容与老师给的表有些区别，老师的表中在淘汰页面时，会将内存中未被淘汰的页面重新放到1号和2号物理块上，再把新添加的页面资源放到3号物理块上。而我上面的计算过程时，并没有对未被淘汰的页面进行重排，而是直接将被淘汰的页面资源去掉，并在相应的物理块上面存入新的页面资源。



可以看出，当分配的物理块从3块增加到4块时，缺页次数增加(从9次增加到10次了)，缺页率提高了(从75%提高到83.3%)。这种异常现象就是抖动现象。



下面我们也可以按最近最少使用算法来对访问上面的页面资源序列，先看看分配3块物理块，然后增加1块物理块，看看它们的缺页次数和缺页率。

最近最少使用算法：Least Recently User，淘汰掉最近最少使用的那个页面资源。

| 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    | 2    | 2    | 2    |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 4    | 1    | 1    |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 3    | 5    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |      |      | Yes  | Yes  | Yes  |

对比先进先出3个物理块时候的缺页情况：

| 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| 1                   | 4    | 4    | 4    | 1    | 1    | 1    | 5    | 5    | 5    | 5    | 5    | 5    |
| 2                   |      | 3    | 3    | 3    | 4    | 4    | 4    | 4    | 4    | 2    | 2    | 2    |
| 3                   |      |      | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 3    | 1    | 1    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |      |      | Yes  | Yes  | No   |

可以发现访问前面的1-9号页面资源时，先进先出和最近最少使用算法的淘汰页面是一样的，但访问第10个页面资源时，对于先进先出算法，由于2号物理块上面的4号资源是最先进入内存的，所以会淘汰2号物理块上面的4号资源，并将2号页面资源存入到2号物理块中。而最近最少使用算法就不一样了，由于我们的第8个页面资源访问的是4号页面资源，第9个页面资源访问的是3号页面资源，第7个页面资源访问的是5号页面资源，现在要访问2号页面资源，可以看到5号页面资源访问后过去的时间最长，因此要淘汰1号物理块上的5号页面资源，将2号资源存放到1号物理块上，这样就看出了两种算法的不同点。

我们计算一下，3个物理块时，最近最少使用算法的缺页和缺页率情况：

访问12次页面资源，产生了9次缺页，缺页率f = 9 / 12 = 75%。此时和先进先出的缺页率相同。

我们增加一个物理块，再看一下最近最少使用算法的缺页和缺页率情况：

| 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| 1                   | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 5    |
| 2                   |      | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    |
| 3                   |      |      | 2    | 2    | 2    | 2    | 5    | 5    | 5    | 5    | 1    | 1    |
| 4                   |      |      |      | 1    | 1    | 1    | 1    | 1    | 1    | 2    | 2    | 2    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  |      |      | Yes  |      |      | Yes  | Yes  | Yes  |

可以看出，访问12次页面资源，产生了8次缺页，有4次没有缺页，缺页率f = 8 / 12 = 66.7%。可以看到，当物理块数增加1后，最近最少使用算法的缺页率降低了。

我们再增加一块物理看一下最近最少使用算法是不是缺页率还会下降：

| 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理块\页面资源序列 | 4    | 3    | 2    | 1    | 4    | 3    | 5    | 4    | 3    | 2    | 1    | 5    |
| 1                   | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |
| 2                   |      | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    |
| 3                   |      |      | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    |
| 4                   |      |      |      | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|                     |      |      |      |      |      |      | 5    | 5    | 5    | 5    | 5    | 5    |
| 是否产生缺页        | Yes  | Yes  | Yes  | Yes  |      |      | Yes  |      |      |      |      |      |

可以看出，增加物理块妻5块时，访问12次页面资源，产生了5次缺页，有7次没有缺页，缺页率f = 5 / 12 = 41.7%。可以看到，当物理块数增加1后，最近最少使用算法的缺页率又降低了。

注意，如果只需要访问1号至5号页面资源，如果再增加物理块的个数，缺页率不会再下降，必定有5次缺页，因为刚开始1、2、3、4、5号页面资源都不在内存中，就会产生5次缺页，后面再新增物理块的话，这几个页面都在内存当中了，新增的物理块对这几个资源没有用，不会再降低缺页率了。



### FIFO先进先出算法与LRU最近最少使用算法的区别

![](/img/Snipaste_2020-10-01_08-42-03.png)

我们来看一下上图中的两种算法的缺页数和缺页率情况。

| 算法 | 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   |
| ---- | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| FIFO | 物理块\页面资源序列 | 5    | 0    | 1    | 2    | 0    | 3    | 0    | 4    | 2    | 3    | 0    | 3    | 2    | 1    | 2    | 0    | 1    | 5    | 0    | 1    |
|      | 1                   | 5    | 5    | 5    | 2    | 2    | 2    | 2    | 4    | 4    | 4    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 5    | 5    | 5    |
|      | 2                   |      | 0    | 0    | 0    | 0    | 3    | 3    | 3    | 2    | 2    | 2    | 2    | 2    | 1    | 1    | 1    | 1    | 1    | 0    | 0    |
|      | 3                   |      |      | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 3    | 3    | 3    | 3    | 3    | 2    | 2    | 2    | 2    | 2    | 1    |
|      | 是否产生缺页        | Yes  | Yes  | Yes  | Yes  |      | Yes  | Yes  | Yes  | Yes  | Yes  | Yes  |      |      | Yes  | Yes  |      |      | Yes  | Yes  | Yes  |
|      | 淘汰页面号          |      |      |      | 5    |      | 0    | 1    | 2    | 3    | 0    | 4    |      |      | 2    | 3    |      |      | 0    | 1    | 2    |



最近最少使用算法：

| 算法 | 序号                | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   |
| ---- | ------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| LRU  | 物理块\页面资源序列 | 5    | 0    | 1    | 2    | 0    | 3    | 0    | 4    | 2    | 3    | 0    | 3    | 2    | 1    | 2    | 0    | 1    | 5    | 0    | 1    |
|      | 1                   | 5    | 5    | 5    | 2    | 2    | 2    | 2    | 4    | 4    | 4    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
|      | 2                   |      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 3    | 3    | 3    | 3    | 3    | 3    | 0    | 0    | 0    | 0    | 0    |
|      | 3                   |      |      | 1    | 1    | 1    | 3    | 3    | 3    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 5    | 5    | 5    |
|      | 是否产生缺页        | Yes  | Yes  | Yes  | Yes  |      | Yes  |      | Yes  | Yes  | Yes  | Yes  |      |      | Yes  |      | Yes  |      | Yes  |      |      |
|      | 淘汰页面号          |      |      |      | 5    |      | 1    |      | 2    | 3    | 0    | 4    |      |      | 0    |      | 3    |      | 2    |      |      |



可以看到，两种算法淘汰的页面号不一样，FIFO算法缺页15次，LRU算法缺页12次，一共访问了20次页面，FIFO算法的缺页率f = 15/20 = 75%，LRU算法的缺页率f = 12/20 = 60%。



## P35 页面淘汰算法练习题

![](/img/Snipaste_2020-10-06_09-21-09.png)

在考试中认同的是这种标准。我们需要按照这种标准来计算。



系统中没有使用快表，是一种暗示提示，说明每读一次程序的块需要先在内存中查询一下表，查询表后才能读取内存块，所以每一块要进行2次对内存的访问，总共有6个块，需要2*6=12次对内存的访问。第1题选B。



注意，缺页中断的计算，这里需要注意，指令无论它占用几个块（页），也是一次性读取整个指令，只产生一次缺页中断。如swap指令是跨了两个页面，swap指令存放在内存的1023单元中，1个K为一个块，1个单元就是一个字节，第一个块是从0个字节到1023字节，1023字节是0号块最后一个单元，只能存指令的一半，还有一半存放在1号块的第个单元当中。跨两个页按常规情况会产生2次缺页中断，但实际上，指令会一次性读入，只产生一次缺页中断。

而对于数据类型的操作数，会产生两次缺页中断。如操作数A在2号页中有一半，在3号页中有一半，在上半部分会产生一次缺页中断，下下半部分也会产生一次缺页中断。所以可以发现总的缺页中断次数是：1 + 2 + 2 = 5次。第2题选C。

因此，在考试中无论认不认同，都要按这种规则来计算，即：

指令存在跨页情况时，是一次性全部读入内存，只产生一次缺页中断。操作数按其跨页次数计算中断数，跨页几个产生几个缺页中断。







## P36 索引文件结构

![](/img/Snipaste_2020-10-20_07-15-47.png)

- 索引文件结构是一种非常巧妙的文件结构，因为这种结构本身的容量很有限，如果不做扩展的话，文件容量很有量，但是引入了扩展后，可以使容量扩大很多倍。
- 一般的索引文件结构有13个索引节点。在考试时如涉及到不是13个标准节点，则会说明节点情况。如果没有说明，则使用标准的13个节点的标准索引节点。
- 在索引文件结构当中，分成了直接索引，一级间接索引，二级间接索引，三级间接索引等情况。
- 分几级间接索引，主要是考虑到文件本身的容量扩展问题。
  - 比方如，一个物理盘块假设是4K的大小，假设13个块都是直接索引，则文件最大为4K*13 = 52K， 这个容量太小。
- 规定0-9号索引结点是直接索引，即前10个节点进行直接索引，直接存放索引文件内容。
  - 直接索引可存放容量为 4K * 10 = 40K。
- 10号索引结点，指向的物理盘块，不再是索引文件内容，而是物理盘块的地址。
  - 假设每一个物理盘块占4个字节，则10号节点可以存放4K/4b = 1024个物理盘块的地址，所以一级间接索引可以存放4K * 1024 = 4M大小的容量。
- 11号索引结点，进行二级间接索引，来扩展容量。
  - 二级间接索引容量就就变成了 4K * 1024 * 1024 = 4G 大小的容量。

例题。

![](/img/Snipaste_2020-10-20_07-52-46.png)

50号物理块号对应的逻辑块号是0，67号物理块号对应的逻辑块号是1，68号物理块号对应的逻辑块号是2，78号物理块号对应的逻辑块号是3，89号物理块号对应的逻辑块号是4。

从90号物理块号开始就不是直接存储逻辑块了，而是间接索引，90空间指向的物理盘块指向的物理块从58号-136号，5号逻辑块存放在58号物理块上。

因为磁盘数据块大小是1KB，而每个地址项大小为4字节，所以90空间可以存放1kB/4b = 1024/4 = 256个地址项，所以90号物理块上逻辑块号从5号开始，后续256-1个地址项，也就是从5号开始，5+256-1 = 260号逻辑块，所以136号物理块存放的是260号逻辑块。

因此要从91号物理块号开始上261号逻辑块，90号物理块号是一级间接索引，指向187号-129号物理块，因此261号逻辑块存放在187号物理块上，因此第1题选C。

101号物理块对应的是iaddr[7]二级间接地址索引表，第2师选D。



## P37 树形目录结构

![](/img/Snipaste_2020-10-20_20-22-26.png)

不仅在计算机中使用相对路径和绝对路径，在实际生活中也会使用相对路径和绝对路径，如拨打电话☎️，打电话时可以加区号或者不加区号，不考虑中国以外地区的话，仅在国内，加区号就是绝对路径，不加区号就是相对路径。



## P38 位示图法

![](/img/Snipaste_2020-10-20_20-27-56.png)

空闲存储空间的管理：在磁盘上有大量的存储空间，我们需要把这些空闲的空间管理起来，以便在某一个文件需要申请存储空间的时候，能够有依据地分配给它相应的空间。空闲存储管理有以下几种方法：

- 空闲区表法（空闲文件目录）：可以用一个表记录哪些地方是空闲的。
- 空闲链表法：把空闲区都链接起来，分配的时候从链表中划出相应的空间。
- 位示图法：需要重点掌握的。
- 成组链接法：即分组又分链。

位示图法：先画一个位示图，1表达的区域表示已经被占用，0表示的区域表示没有被占用，是空闲的。我们把整个的存储空间分为多个物理块，就可以直观的看出哪些物理块被占用，哪些物理块是空间。

实际生活中，电影院卖座位也应用了位示图法，如红色座位表示已经卖出的座位，绿色或空间座位表示还没有被卖出的座位。买飞机票或火车票也会使用位示图法。

![](/img/Snipaste_2020-10-20_20-37-04.png)

示例分析：

1个字是32位，4195号物理块对应第4196个物理块，因为物理块是从0号开始编号的。

所以可以使用 ( 4195 + 1) / 32 = 131.125， 说明要把前面131个字填满，并且当前物理块处于第132个字中。因此在132个字中，第1题选D。

![](/img/Snipaste_2020-10-20_20-42-17.png)

第131个字： 131 * 32 = 4192，因此从第1个字（注意，第几个字是从1开始编号的，不是从0开始编号的）到131个字可以表示第0号物理块到第4191号物理块。

在第132个字中：

第0位置：对应4192号物理块，

第1位置：对应4193号物理块，

第2位置：对应4194号物理块，

第3位置：对应4195号物理块，

因此将4195号物理块分配给某文件时，需要将第132个字的第3位置为1，1表示占用。第2题选B。



需要注意的是：

- 第多少字是从0还1开始算？从1开始算，第1个字，第2个字。
- 第多少位是从0还是1开始算？从0开始算，第0位，第1位，第2位等。





## P39 数据传输控制方式

![](/img/Snipaste_2020-10-20_20-53-52.png)

- 设备管理-数据传输控制方式，主要是指内存和外设之间的数据传输控制问题，解决这一问题，有几种方案可以选择，包括：

  - 程序控制方式
  - 程序中断方式
  - DMA方式
  - 通道
  - 输入输出处理机

  其中的通道和输入输出处理机需要专用的计算机来解决程序控制方式，一般不在讨论范围之内，主要考虑前面三种控制方式。

- 程序控制方式：又被称为程序查询方式，这种方式是最低级的，也是CPU介入最多的机制，整个数据传输控制，很多时候需要cpu的介入，在这种方式中，外设处于一种非常被动的方式，它不会主动的反馈信息，比如传输完成没有，情况怎么样，而是由CPU发出查询指令，查询有没有传输完成，没有传输完成继续传输，传输完成了就继续下一步的工作。类似于给员工分配一个任务，你要经常去问他有没有完成工作，刚开始问的时候他一直说没有完成，你就做别的事情去了，你再次来问他工作完成没有，他就告诉你他老早就完成了工作，这必然会带了一些问题。这样后来就出来了程序中断方式。

- 程序中断方式：与程序控制方式一样，但是更主动，如果外设完成了相应的数据传输任务，就发出一个中断出来，系统就会就下一步的处理，这样效率就比程序查询方式高一些。

- DMA方式：又称为直接存储控制方式，思路：有专门的DMA控制器，只要是外设和内存之间的数据交换，过程中间由DMA控制器管控，CPU只用在开头的时候介入，如安排好事务，初始化等，整个过程由DMA控制器来完成、处理、监管，完成之后再由CPU接手过来，做后续的操作，这样效率就提高很多。





## P40  设备管理-虚设备和SPOOLING技术

![](/img/Snipaste_2020-10-20_21-12-26.png)

- 虚设备和SPOOLING技术使用一个实例来说明即可，大家理解一下基本原则即可。

如A/B/C/D四个人在不同的方式连接到远程的打印机，打印机放在打印房里的。我们知道打印机在同一时刻只能服务一个用户，不能说四个人打印资料，一人打印一页，一页A的，一页B的，一页C的，一页D的，这样子不行，必须时先把一个任务打印完成了后再打印别的。这个时候共用打印机资源就会产生一个问题，我在打印资料的时候，发布打印指令，结果有可能提示‘"打印机正在使用！！"，我等10分钟再去打印，又提示"打印机正在使用！！"，我又等10分钟再去打印，又提示"打印机正在使用！！"，而实际上我们发现打印机利用率其实并没有那么高，可能刚好你要打印的时候，别人正在打印，就会提示打印机正在使用，这个时候外设利用率非常低。因此就提出了SPOOLING技术。

SPOOLING技术是怎么做的呢？

SPOOLING技术应用非常广泛，打印机上面就应用了这种技术。A,B,C,D都要打印，在打印机这边会有相应的控制程序做打印的管控，管控的时候会先把相应的需要输出的内容放到磁盘的缓冲区，进入到输出井，完成之后，打印机会顺次打印输出井里面的数据内容。即你在打印的时候不会提示你打印机正在使用，而且进度表已经过去了，等打印机把前面的任务打印完成就会开始打印你的打印任务。所以说通过加入SPOOLING技术，使用过程变得更加友好，你可以随时点击打印，打印完成后只用去打印房拿资料就可以了，不会老是出来冲突的问题。

SPOOLING技术的核心就在于开辟了缓冲区，让需要输出、输入的数据先缓存起来，这样解决了外设的低速和内部系统高效之间的瓶颈差异，一般系统都内置了SPOOLING技术。因为像打印的话不仅与其他用户有冲突，自己打印多个文档的时候也会产生冲突，比如打印文档A 100页，再打印文档B就会提示设备已经占用，有了SPOOLING技术后就不会提示打印机占用，打印会显示打印队列，打印机顺次处理。



SPOOLING技术在磁盘上开辟缓冲区，解决速度之间的差异。



## P41 微内核操作系统

![](/img/Snipaste_2020-10-22_07-19-28.png)

- 微内核操作系统

微内核操作系统就是把内核做得更小的操作系统。

为什么要将操作系统的内核做得更小呢？必然是有它的好处优势的。好处优势主要体现在：微内核操作系统的可靠性、稳定性、安全性更高。

操作系统作为核心的系统软件，如果操作系统出现了故障，就会影响整个系统的正常运行，如果把操作系统内核做得小一些，就会降低这种问题发生的概率，把最为核心的放在内核里，只有这一小块的东西出故障才会产生根本性的影响，而原来放在操作内核里的抽离出去，作为其他的外接系统，这些系统即使出现故障问题，我们只需要去重启这一小块的功能部件的东西，就能解决这个问题，比如把图形系统，文件系统，设备驱动等放在内核之外，假设文件系统崩溃，对于微内核系统而言，没有关系，只用将文件系统重启一下即可，不用重启整个系统；如果是单体内核系统，如果文件系统出现故障了，那就表现为整个系统出现问题了，比如以前用到的XP系统经常蓝屏，就是内核出现问题，当把内核缩小了，这种问题的概率就大大的降低了。 

具体查看表中的内容，主要了解这种思想。

| 内核类型 | 实质                                                         | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单体内核 | 将图形、设备驱动及文件系统等功能全部在内核中实现，运行在内核状态和同一地址空间。 | 减少进程间通信和状态切换的系统开销，获得较高的运行效率。     | 内核庞大，占用资源多且不易剪裁。系统的稳定性和安全性不好。   |
| 微内核   | 只实现基本功能，将图形系统、文件系统、设备驱动及通信功能放在内核之外。 | 内核精练，便于剪裁和移植。系统服务程序运行在用户地址空间，系统的可靠性、稳定性和安全性较高，可用于分布式系统。 | 用户状态和内核状态需要频繁切换，从而导致系统效率不如单体内核。 |

微内核操作系统中分用户态和核心态，核心态是微内核里面内核运行的情况，用户态是核心态之外去运行的，也就是说，在用户态出现的故障都没有关系，都可以通过一定的处理方式来解决，但核心态出现故障就会比较严重。用户态和核心态之间会有交互，普通的东西在用户态处理，只有到了非常关键的部分才到核心态里面去处理，就是和系统内核紧密关联的才在核心态处理。

上面的图需要记住哪些态是在核心态，哪些是在用户态。





## P42 数据库系统前言

![](/img/Snipaste_2020-10-22_07-47-32.png)

数据库系统主要涉及以下内容：

- 数据库模式
- ER模式
- 关系代数和元组演算，每次上午题都会考。
- 规范化理论
- 并发控制
- 数据完整性约束
- 分布式数据库
- 数据仓库与数据挖掘

## P43 数据库三级模式两级映射

![](/img/Snipaste_2020-10-22_07-52-00.png)



一般以选择题形式出现。

三级模式两级映射这种设计是层次型架构设计，这种层次型架构设计为我们在应用数据库时提供了很多方面的便利，同时也让整个体系的可维护性、应变能力变得更好一些。



三级模式两级映射到底是什么回事？

- 最底层是物理数据库，说白了物理数据库在计算机上面表现形式是一个文件，如数据库文件日志文件等。
- 内模式是与物理层次的数据库直接关联的，内模式管理如何去存储一系列的数据，数据需要存储到物理文件上，按什么格式存储，如何去优化它，主要关注数据的存放。
- 概念模式，其实就是平时用数据库中表这一级，将数据分成若干个表，这些表是根据业务、应用划分的，表之间会存在关联。
- 外模式，对应数据库的视图，外模式的应用，使对数据的控制有更进一步的手段更加灵活的处置方式。对表进行相应的操作，得到不同的视图。表发生变化，只需要改表映射，不需要去改变应用程序。



## P44 数据库设计过程说明

![](/img/Snipaste_2020-10-23_07-42-01.png)



需要了解数据库整个设计过程流程是怎样的？每一个阶段会有不同的产出物。



- 需求分析：需求分析是看整个系统对数据这一块有什么样的要求，有从用户那里收集过来的，同时由转换过程中产生的一些需求，关联的一些需求，在这一个阶段，需要有数据流图、数据字典、需求说明书等产物，严格来说，需求分析是上一个阶段需求阶段的任务，而数据库设计具体应从概念结构设计开始。
- 概念结构设计：就是做E-R模型，ER模型与数据库管理系统没有关系的模型，ER模型做出来后，你可以用Access,MYSQL等等数据库，ER模型这一层与物理数据库没有直接的关系。就是一种数据的表达，看数据的实体会有哪些属性，看实体之间会有什么样的联系，分析这些方面的问题。接着需要将E-R模型转换成关系模式。
- 逻辑结构设计：E-R模型转换成关系模式是转换成文字表达一个一个表的形式，在转换过程中就涉及到规范化理论，规范化理论是必考的知识点，产出物是关系模式。
- 物理设计：有了关系模式后，进一步把数据库管理系统的特性融入进入，比如说不同的数据库管理系统类型可能不同，在设计的时候值得注意和考虑，形成物理层次的设计。

这是整个数据库的设计流程。



## P45 E-R模型

![](/img/Snipaste_2020-10-23_08-01-25.png)

- 以方框表示实体，如学生实体，课程实体。
- 以椭圆表示属性，如学生实体有学号、姓名、性别、年龄等属性，课程实体有课程号、任课教师、课程名等属性。
- 以菱形表示联系，学生与课程之间会有联系，一个学生可以选不同的课程，一门课程又可以被多个学生选择，是多对多的关系。

在进行E-R图的设计过程中，往往需要分析每一个局部的E-R该如何设计和绘制，因为从整体的角度，一个庞大的系统ER图一次性绘制出来，难道比较高，风险比较大，所以一般是先画局部的ER图，然后再把局部的ER图一步一步的合成起来，形式全局的ER图。



在将多个局部ER图合成时，又可以选择不同的集成的方法：

![](/img/Snipaste_2020-10-23_08-11-09.png)

- 逐步集成：首先将两个局部集成在一起，再与另外一个集成，这样耗时一些，但简单一些，不容易出错。
- 多个局部图一次集成：有可能会出现一些问题，难以发现。

在集成的过程中还会面临一个问题就是冲突问题，就是两个图不一致的情况。

在集成的过程中会产生的冲突及解决办法：

- 属性冲突：包括属性域冲突和属性取值冲突。如教师表，有的系统设计性别为男/女，有的系统设计性别为逻辑值如T/F，这样属性值就会有差异。
- 命名冲突：包括同名异义和异义同名。如教师在学生表里面写的是老师，而在教职工表里面写的是职工，所以同样的意思在不同系统中命名不一样就可能产生问题。
- 结构冲突：不同抽象级别的问题。如老师即一个表，也可能是另外一个系统中的一个列。这样也可能产生问题。



### E-R模型转关系模式

![](/img/Snipaste_2020-10-27_07-17-09.png)

- 一个实体型转换成一个关系模式：

  - 1对1联系(1:1)：每个实体可以转换成一个关系模式，可以把联系单独转换成一个关系模式，这样就是3个关系模式； 也可以把联系记录在实体上，这样就是2个关系模式，所以1对1联系至少可以转换为2个关系模式。如实体A转换成一个关系模式，实体B转换成一个关系模式，可以将中间的菱形◇联系单独的转换成一个关系模式，也可以将菱形◇联系合并到与之关系的任意一个实体里面，即关系即可记录在实体A里面，也可以记录在实体B里面，这样1对1联系至少可以转换为2个关系模式。
  - 1对多联系(1:n)：每一个实体需要转换成一个关系模式，可以将中间的联系单独转换成一个关系模式（这种做法可以，但不是必须的），也可以将联系记录在n（多的一端）端。如果记不住，可以使用员工与部分的关系来记忆，如A是部门，B这边是员工，部门和员工是1对多关系，即一个部门有多个员工，一个员工只能属于一个部分，关系只能记录在员工这边，只用在员工表里面加上部门号就可以解决，就可以对应到相应的部门； 反过来就不行，如在部门中加上员工号，有的部门人比较少，可能只有两个，就要写两个员工号进去，部门人员多的，有几百个，把它添加到同一条记录里面，这时候就没办法添加了，所以说在员工这一边加上部门号是比较好的方案。所以一对多的关系中，至少可以转换成2个关系模式。
  - 多对多联系(m:n)：多对多有一个现成的实例，如学生与课程之间就是多对多的关系，学生实体可以选择多个课程，课程实体也可以被多个学生选择，学生实体需要转换成一个关系模式，课程实体也需要转换成一个关系模式，选课联系必须转换成一个关系模式，所以对于多对多的关系中，至少需要转换成3个关系模式。

  ![](/img/Snipaste_2020-10-27_07-36-04.png)

  对于上图中的示例，A/B/C三个实体分别需要转换成一个关系模式，中间的多对多的联系也需要转换成一个关系模式，因此最少需要转换成4个关系模式。

  从这里我们可以看出，即使是和三个实体产生关系，是多对多对多的，我们也可以将这个联系转成1个关系模式，而不需要去转换成多个关系模式。

## P46 关系代数

![](/img/Snipaste_2020-10-27_07-40-51.png)

![](/img/Snipaste_2020-10-27_07-46-51.png)

![](/img/Snipaste_2020-10-27_08-00-58.png)

![](/img/Snipaste_2020-10-27_07-55-59.png)

![](/img/Snipaste_2020-10-27_08-02-14.png)

- 并，典型的集合运算，把两个集合的内容的并在一起，并且将两个表中都有的记录只显示一次，重复的只显示一次。
- 交，典型的集合运算，把公共部分找出来，形成新的关系。
- 差， 典型的集合运算，A有B没有的，将公共部分去掉。
- 笛卡尔积，将两个表进行合并，S1中的每条记录需要与S2中的每条记录进行拼接，结果集中，属性数是参与操作的两个表的属性值之和，记录条数是两个表的记录数之积。
- 投影，选出哪些需要的列，其他列不需要。投影时可以使用列的序号表示，如Pai1,2(S1)与图片中的等价，1代表第1列，2代表第2列。
- 选择，选择的是记录，选择的是行。选择的时候，也可以用同样的方法，Sigama1(S1)，1代表第1列，即Sno列。
- 联接，联接是进行等值联接，**将两个表中都有的字段只保留一个**，如使用S1.Sno = S2.Sno条件，这个时候连接后，Sno就只剩下一个。如果不写条件的话，就是自然联接，条件就是两个关系当中相同的字段做等值，即对于这个表默认就是S1.Sno = S2.Sno条件。



做笛卡尔积或联接后，再做投影的话，要注意最后生成的列数，笛卡尔积列数是两个表的列数之和，而联接会去掉一个公共字段，少一列！！！





## P47 规范化理论-函数依赖

![](/img/Snipaste_2020-10-28_07-37-02.png)

![](/img/Snipaste_2020-10-28_07-39-17.png)

函数依赖是规范化理论的基础知识点，是后面要讲的主键、范式等的基础。给定x能够确定y,则称y函数依赖于x. x->y。

如在数据库中，学号可以确定姓名，但姓名不能确定学号，如出现重名时，一个姓名可能会对应多个学号。



部分函数依赖：如以(学号，课程号)组合键可以确定姓名，而且与此同时，学号也是可以确定姓名，即主键是两个属性的组合键，其中的一部分可以确定某个属性，这就是部分函数依赖。

传递函数依赖：比较简单，A确定B，B确定C,则可以推论出A确定C，这就是传递函数依赖。这里B不能确定A，因为如果B能确定A，则说明A和B等价，如果是等价的，则不存在传递性的说法。



有了函数依赖的基础后，我们就可以看后面的问题了。



## P48 规范化理论的价值与用途

![](/img/Snipaste_2020-10-28_07-50-37.png)

非规范化的关系模式，可能存在的问题包括：数据冗余、更新异常、插入异常、删除异常。

数据冗余：如示例表中，D01、计算机系、1号楼等这些关于计算机系的信息就存在大量的冗余，每个学生都对应一个系，导致系会重复多次记录，这就是冗余。

更新异常：另外，如果将第一条的计算机系更名为计算机科学系，但是后面的数据中并没有更新，这时候就会导致更新异常，因为都是D01，但对应的系名却不一样。

插入异常：如两个属性组合作为主键时，当一个属性不明确时，就没办法插入数据。

删除异常：删除了不应该删除的数据。



规范化理论的价值与用途是降低数据冗余，消除掉更新异常、插入异常、删除异常等异常情况。



非规范化理论：也称为反规范化理论，如加数据冗余等。



设计没有绝对的标准，没有说把规范化做得更高的级别，比如将一项指标提高，另一项指标可能会降低。

如将安全提高，有可能性能就会降低！



## P49 规范化理论-求候选关键字

![](/img/Snipaste_2020-10-29_07-11-56.png)

- 超键：要求最低的概念，要求唯一标识元组，超键可能存在冗余属性，在超键的基础上消除多余属性就是候选键。
- 候选键：唯一标识元组，在超键的基础上消除多余属性，就是候选键。如（学号、姓名）可以确定性别，（学号、姓名）组合键可以称为超键，但不能称为候选键，因为可以通过学号就可以确认性别，也可以通过（学号、姓名）确认性别，所以姓名是一个冗余属性，将姓名属性去掉，通过学号确定性别，这个学号就是候选键。当有多个候选键时，只能从这些候选键中选择一个候选键设计为主键。
- 主键：在多个候选键中选择一个设置为主键。类似于一个国家竞选总统，有多个总统候选人，最终选出来的总统只有一个。在数据库中，可以有多个候选键，如几个字段都可以设置为主键（也就是候选键），但是只能挑选其中的一个做为主键，比如即有学号又有身份证号，学号和身份证号都能唯一标识一个人，所以可选择学号做为主键，也可以选择身份证号做为主键，二选一，但不能同时设置两个为主键，这就是候选键与主键的差别。
- 外键：别的关系的主键。很多时候需要对表做关联处理。如在员工表里面设置一个部门号，部门号用来和部门表进行关联，部门号对于员工表就是一个外键，外键主要是用来进行关联查询的。

### 求候选键

![](/img/Snipaste_2020-10-29_07-28-25.png)

![](/img/Snipaste_2020-10-29_07-32-35.png)

![](/img/Snipaste_2020-10-29_07-35-48.png)

- 使用图示法求解候选键。
- 入度为0的属性，就是没有箭头指入进来的。出度就是有箭头指出。
- 候选键需要能够遍历全图。
- 注意绘制组合键时，需要将多条线先汇成一个节点，然后再从这个节点连出一个箭头到其他的位置。
- 如果没有入度为0的，那么要找一个即有入度又有出度的，再看这个关键字是否能遍历所有关键字。

所以，按以上方法，可以知道例题中：

第1题选A,R的候选关键字是A1。

第2题候选码是ABCD组合键。

第3题选B,关系R的候选关键字为A和B，即A和B都可以做为候选键。



## P50 规范化理论-范式

![](/img/Snipaste_2020-10-29_07-39-28.png)

范式几乎是必考的内容。函数依赖、候选键的求解是范式的基础。

范式可以分第一范式、第二范式、第三范式、BC范式、以及级别更高的第四范式。

但是范式级别不断提高时，规范化程度越来越高，与此同时带来一个问题，规范化程序越高数据的粒度越来越小。提高范式级别，基本上就是通过对数据表进行拆分，越高级别的范式时，数据拆分得越细，把数据一步步拆分的非常细的时候，往往又带来性能方面的问题，所以一般采取比较平衡折中的方式，就是把范式做到第三范式左右就差不多了，不要求进一步往更高级别去深入。

范式级别最低的是第一范式(1NF)，更高的是第二范式(2NF)，要达到第二范式必须达到第一范式；再高的是第三范式(3NF)，要达到第三范式必须达到第二范式。.... 级别越高规范程度越高。

- 第一范式(1NF)： 属性值都是不可分的原子值。所谓原子值是指这个属性不能再拆分为几个属性。
- 第二范式(2NF)：在第一范式的基础上，如果消除了非主属性对候选键的**部分依赖**就达到第二范式。
- 第三范式(3NF)：在第二范式的基础上，如果消除了非主属性对候选键的**传递依赖**就达到第三范式。
- BC范式(BCNF)：在第三范式的基础上，如果消除了主属性对候选键的传递依赖就达到BC范式。
- 级别越高，规范化程度越高，更有可能去解决插入异常、更新异常、删除异常、数据冗余等问题。如将数据表从第一范式规范到第二范式，解决了一些问题，但仍然有可能有插入异常、删除异常、数据冗余等问题，达到第二范式，进入到第三范式，这种情况还是有可能上述问题，所以需要一步一步的深入处理。不同的范式，规范了不同的情况。



### 第一范式1NF

![](/img/Snipaste_2020-10-29_08-00-15.png)

- 第一范式(1NF)： 所有域只能包含原子值，每个属性值都是不可再拆分。示例表中的高级职称人数就不满足第一范式，因为高级职称人数可以拆分为教授和副教授，不满足第一范式的要求，要消除这种情况，将高级职称人数说法去掉，直接保留教授和副教授，就样就达到第一范式。要达到第一范式是非常简单的。

### 第二范式2NF

![](/img/Snipaste_2020-10-29_20-42-41.png)

- 第二范式2NF：必须先是第一范式，并且每一个非主属性完全依赖主键（即不存在部分函数依赖）时，则是第二范式2NF。

示例中，主键是SNo和CNo的组合键，SNo是学生号，CNo是课程号，Grade是成绩信息，Credit是课程学分信息。需要通过SNo和CNo才能确定Grade成绩信息，因为只有同时使用学生号SNo和课程号CNo才能确定该学生该门课程的成绩，仅用学生号或课程号都不能确定成绩，这个关系模式的候选键是SNo和CNo的组合键。学分Credit是能够通过课程号CNo来确定的，存在部分函数依赖，因为通过CNo课程号就可以确定Credit学分，而CNo课程号只是主键（SNo和CNo的组合键）的一部分，这就存在了部分函数依赖。要解决这种问题，就需要对表进行拆分。

主属性: 所谓主属性是指这个属性是候选键的一部分。示例中SNo学生号和CNo课程号是主属性。

非主属性：所谓非属性是指这个属性不是候选键的一部分。CNo课程号和Grade成绩是非主属性。

判断主属性和非主属性的核心是判断哪些是候选关键字，是候选关键字的属性是主属性，不是候选关键字的属性是非主属性。



部分函数依赖带来的问题：

- 数据冗余，比如学分保存了很多次，这是不必要的，因为每一门课程都在固定的学分，其实只需要保存一个课程号CNo与学分Credit的对应关系就行。
- 更新异常：现在课程C01对应的学分是4，如果更新第1条记录，不更新2-4条记录，那么这时候就存在问题，一个课程不能对应多个学分，更新一部分不更新一部分就会有问题，这样就是更新异常。
- 插入异常：如果我们有一个新的课程C08，对应的学分是6分，如果要把这个信息插入到表中，这时候就没办法插入了，因为还没有学生选择这门课程，而表中的记录没有学号，学号是主键，必须是有值的，不能为空，但这时候没有学生选这门课，这时候就插入不进去。
- 删除异常：如这一届学生毕业了，将成绩信息全部清除，这个时候学分信息也会被清除，这就是删除异常。 

解决以上问题的办法是：将CNo课程号与Credit学分这两个字段提取出来，做一个新的关系模式即可，然后把原来表的Credit学分列给去掉，注意，不能将原来表的CNo课程号去掉了，去掉CNo课程号会导致原来的信息不完整。

- 单属性作为主键时，就不存在部分函数依赖，就满足第二范式。

### 第三范式3NF

![](/img/Snipaste_2020-10-29_21-06-38.png)

- 第三范式3NF： 当仅且当R是第一范式1NF，并且没有非主属性传递依赖于码时，则称R是第三范式3NF。
- 第三范式其实已经达到第二范式的要求。

示例中，表已经达到第二范式2NF要求，因为SNo已经被标识出来是主键，知道这一点不去细致分析，就知道它满足第二范式2NF。

- 它的主键只有单属性SNo，单属性是不可能有部分函数依赖存在，这样就属于第二范式2NF。

虽然这个表已经达到第二范式2NF，但通过表中可以看到仍然存在问题，如：

- 数据冗余：从DName系名，Location位置可以看到冗余数据比较多。
- 更新异常：如更新系名，如果只更新一部分另一部分不更新，就会存在更新异常，会出现系名不一致的情况。
- 插入异常：如果新建一个系，这时候没有学生属于这个系，就没有办法录入这个新的系的信息。
- 删除异常：相应的也会出现删除异常。

解决以上问题的办法是：将DNo系号、DName系名和Location位置三个字段提取出来，做一个新的关系模式即可，打破传递依赖。原来表中删除DName系名和Location位置列，原来关系模式只剩下前面的三个字段SNo学生号、SName学生姓名和DNo系号。



### BC范式BCNF

![](/img/Snipaste_2020-10-29_21-20-50.png)

- BC范式：第三范式3NF消除主属性对候选键的传递依赖就达到了BCNF。

示例中，先找出所有候选键，入度为0的只有S，如果只选S做为候选键是否可行？不行，因为T是由S和J共同决定的，单独是S到不了T。可以看到SJ是一个候选键，同时ST也是一个候选键，因为T可以确定J, 可以遍历完所有的节点。

这时候可以知道，S、J、T都是主属性，没有非主属性，所有关系必须满足第二范式2NF（消除非主属性对候选键的部分函数依赖）和第三范式3NF（消除非主属性对候选键的传递函数依赖），现在连非主属性都没有，那么必定满足第三范式3NF。

![](/img/Snipaste_2020-10-29_21-38-52.png)

示例中存在的函数依赖有：SJ --> T 以及 T  --> J， 即SJ确定T，T确定J,很明显第一个函数依赖左边部分是候选键，而第二个函数依赖左边部分T不是候选健，所以可以判断这一个关系模式还没有达到BC范式的要求。













